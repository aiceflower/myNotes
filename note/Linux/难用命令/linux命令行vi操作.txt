常用：
vi fileName 启动编辑器
hjkl 将光标分别向左、下、上、右移动一个字符
0(零)或^(脱字符) 将光标移到当前行的行首
##G  42G将光标移到文件的第42行
按行查找  :42 这样就是找到第42行
G 将光标移到文件的最后一行
12| 将光标定位到当前行的第12列
- 将光标定位到上一行的行首
+ 将光标定位到下一行的行首
L 将光标定位到“屏幕”的最下面一行
M 将光标定位到“屏幕”中间的一行
H 将光标定位到“屏幕”的最上面一行
/word向下查找word ?word 向上查找word
n 将光标移到前面命令/word或?word中指定模式的下一个实例 即寻找下一个查找的单词
:set nu显示行号
:12,35 move 58命令将第12～35行之间的所有文本移到第58行的后面
:1,26 co 82 将第1～26行之间的所有文本复制到第82行的后面
:#,# s/target/replacement/g 在指定的行上进行全局替换。
:n1,n2 d将第n1行到第n2行之间的内容删除
xp:交换当前与下一个字符
ddp:交换当前行与下一行



1.打开操作
从shell中启动可视化编辑器
vi filename 指示shell启动vi编辑器，并将参数filename传给它。如果当前目前中存在该文件，
则vi编辑器将它解释为要打开的文件；如果没有该文件，则vi编译器创建新文件
vi file1 file2 file3 shell传递3个参数给vi，vi将它们解释为要打开的文件。
可以使用:w命令保存文件，使用:n命令访问下一个文件
vi +# filename 打开文件，并将光标移到指定的行。
例如，命令vi +100 records 从第100行开始编辑文件records
vi +/the filename 打开文件，并将光标移动包含有目标字符串的行。
例如，命令vi +/Jason friends 从第1个含有字符串Jason的行开始编辑文件friends
view filename 打开文件进行编辑，但是拒绝保存对文件的修改，除非使用w!命令

2.光标移动操作
hjkl 将光标分别向左、下、上、右移动一个字符
0(零) 将光标移到当前行的行首
^(脱字符) 同0一样将光标移到当前行的行首
$ 将光标移到当前行的行末
##G 将光标移到G前面的数字指定的行。例如，42G将光标移到文件的第42行
G 将光标移到文件的最后一行
w 将光标向前移到下一个单词的首字母
e 将光标向前移到下一个单词的最后一个字母
b 将光标向后移到上一个单词首字母
- 将光标定位到上一行的行首
+ 将光标定位到下一行的行首
12| 将光标定位到当前行的第12列
L 将光标定位到屏幕的最下面一行
M 将光标定位到屏幕中间的一行
H 将光标定位到屏幕的最上面一行
” 两个单引号将光标移到它的先前的位置的行首

3.光标定位命令（上下文的）
fb 将光标向前移到当前行上的下一个字母b（或者其他的任意指定的字符）
Fb 将光标向后移到当前行上的上一个字母b（或指定的字符）
t# 将光标移到当前行上字符＃的第1个实例的右侧。例如，命令tM将光标移到当前行上第1个M的右侧
T# 在当前行上向左移动光标，将它移到字符＃的第1个实例的前一字符
/word 将光标向前移到单词word的下一个实例
?word 将光标向后移到单词word的上一个实例
按行查找  :90 这样就是找到第90行
n 将光标移到前面命令/word或?word中指定模式的下一个实例 即寻找下一个查找的单词

4.显示调整命令
Ctrl+D 显示文件中的下半屏文本
Ctrl+U 显示文件中的上半屏文本
Ctrl+F 显示文件中的下一屏文本
Ctrl+B 显示文件中的上一屏文本

5.设置显示选项
:set number 将行号作为屏幕显示的一部分，但是行号并不是文件的一部分。它的缩写形式为:set nu
:set nonumber 清除屏幕上的行号。也可以使用缩写形式:set nonu
:set showmode 在屏幕的右下角显示追加模式信息
:set list 在每行的行末显示美元符号，并用Ctrl+I表示制表符
:set showmatch 在输入）或］时，将光标移到与之匹配的（或[
:set window=value 定义屏幕上显示的文本行的行数
:set autoindent 自动缩进。也可以使用缩写形式:set ai
:set tabstop=value 设置显示制表符的空格字符个数。也可以使用缩写形式ts=value
:set wrapmargin=value 设置显示器的右页边。当输入进入所设置的页边时，编辑器自动回车换行
:set ignorecase 指示编辑器搜索字符串，并忽略目标中字母的大小写
:set 显示设置的所有选项
:set all 显示所有可以设置的选项
set hlsearch "高亮度反白
set hackspace=2 "可随时用退格键删除
set autoindent  “自动缩排
set ruler ”可显示最后一行状态
set showmode  “左下角那一行的状态
set nu ”显示行号
set bg=dark “显示不同的底色
syntax on ”进行语法检验，颜色显示
在一般模式下读取另一个文档  :r filename 
	:n 编辑下一个文档
	:N 编辑上一个文档
	:files  列出目前这个vim的开启的所有文档
全文替换  :1,$s/word1/word2/g[c]  c用来决定要不要确认
区块选择：
	v 字符选择，将光标经过的地方反白选择
	V 行选择...
	ctrl+v 区块选择 
	y 复制反白的地方
	d 删除反白的地方
多窗口功能：
	:sp [filename]
	ctrl + w +j(或下箭头)  下方窗口   按ctrl 再按 w 放开所有 按 j或箭头
	ctrl + w +k(或上箭头)   上方窗口
	ctrl + w +q 离开
	或是ctrl+ww 来切换窗口
vim中常用设置
	在/etc/vimrc中不过不建议修改
	可以将设定的值写入 ~/.vimrc这个文档中
	常用设置：“为批注
	
6.文本删除命令
dd 删除当前光标所在的文本行
#dd 删除＃行文本
dw 从文本中删除一个单词
#dw 从文本中删除＃个单词
x 删除光标所在的一个字符
#x 从文本中删除＃个字符
D 删除当前行上光标后面的部分
d0删除当前行上光标前面的部分
删除全部  dG  这里注意G一定要大写
:#,#d 例如，:12,37d 将删除第12～37行之间的所有文本，包括第12和37行

7.撤销命令
u 撤销。恢复最近一次的文本修改操作，即使已经移动了光标。在Linux系统中，再次使用撤销命令将恢复更前一次的文本修改操作。
在BSD的vi中，第2次撤销操作将撤销第一次撤销操作，恢复第1次撤销前修改的文本
:redo 在Linux系统中，取消撤销操作恢复文本修改。在标准的UNIX系统中，第2个u命令取消第1个u命令，结果就是一个“redo”
U 如果在修改后还没有将光标移出当前行，则可以撤销对当前行进行的所有的文本修改
ctrl+r恢复上一次撤销的操作

8.向文本中添加文本(即进入编辑状态)
a(小写) 从光标的右侧开始插入文本
A(大写) 从当前行的行末开始添加文本
i(小写) 从光标的左侧开始插入文本
I(大写) 从当前行的行首插入文本
o(小写) 在光标的下面打开（或插入）一个新行
O(大写) 在光标的上面打开一个新行
:#r filename 例如，:8r report.old读取文件report.old，并将它的内容放到当前文件的第8行之后
Esc 无论使用什么命令进入了追加/插入模式，都可以通过按Esc键离开追加模式返回到vi的命令模式
Ctrl+V 允许输入控制字符。按Ctrl+V键后再按回车键将把Ctrl+M插入到文件中

9.在文件中修改文本
cw 仅仅修改光标处的单词（删除单词，然后进入追加模式中，以在被删除单词的位置添加文本）
s(小写) 替换单个字符
S(大写) 替换整行文本
cc 替换整行文本(同S)
r 用输入的下一个字符替代当前光标处的字符，并自动返回到命令模式
R 将编辑器放到覆盖模式，用输入的字符来逐个替换光标处的字符
C(大写) 修改行上从光标到行末之间的文本
ct# 修改行上从光标到前向第1个目标字符之间的文本。
例如ctY将删除当前行上从光标到向前第1个字符Y之间的所有文本，并进入追加模式以在删除文本的位置添加文本
cf# 修改行上从光标到前向第1个目标字符之间的文本（包括目标字符）。
例如cfY将删除当前行上从光标到向前第1个字符Y之间（包括Y）的所有文本，并进入追加模式以在删除文本的位置添加文本
cT# 修改行上从光标到后向第1个目标字符之间的文本。
例如cTY将删除当前行上从光标到向后第1个字符Y之间的所有文本，并进入追加模式以在删除文本的位置添加文本
cF# 修改行上从光标到后向第1个目标字符之间的文本（包括目标字符）。
例如cFY将删除当前行上从光标到向后第1个字符Y之间（包括Y）的所有文本，并进入追加模式以在删除文本的位置添加文本

10.接出和粘贴行的单词
yy 将当前行复制或接出到内在缓冲区。20yy将当前行和它后面的19行（共20行）
文本复制到内存。目标行仍然保留在文件中，可以使用p命令将这些内存中的文本粘贴到文件中
dd 删除当前行，并将它放到与yy命令使用的相同的内存缓冲区。
即：yy和dd之后都可用p来粘贴
目标行从文件中删除，但是可以使用p命令将它粘贴到文件中的其他地方
yw 将当前光标所在的单词接出或复制到内在缓冲区。
6yw命令将把当前单词和它后面的5个（共6个）单词复制到内存
dw 删除当前的单词，并将它放到与yw命令使用的相同的内存缓冲区。
可以使用p命令将单词粘贴到文件的其他地方
yt# 接出从光标到向前一个字符（不包括该字符）之间的文本。
例如，ytB命令将从光标到字符B的下一实例（不包括字符B）之间的文本接出或复制到内存
yf# 接出从光标到向前一个字符（包括该字符）之间的文本。
例如，yf:命令将从光标到字符:的下一个实例（包括字符:）之间的文本接出或复制到内存
yT# 后向接出（不包括目标字符）。
例如，yTN命令将从光标到字符N的后向第1个实例之
间的文本（不包括字符N）接出或复制到内存
yF# 后向接出（包括目标字符）。
例如，yFJ命令将把从光标到字符N的向后第1个实例之间的文本（包括字符N）接出或复制到内存
p 将内存中的文本行粘贴到文件中光标所在行的下面，或将内存中的单词粘贴到文件中光标的右侧
P(大写) 将接出或删除的文本行粘贴到文件中光标所在行的上面。或将接出或删除的单词粘贴到文件中光标的左侧

11.文件移动命令
J 将下行文本同当前行合并成一行
:#,# move # 将指定的行移到目标位置。:12,35 move 58命令将第12～35行之间的所有文本移到第58行的后面。缩写为mo
:1,26 co 82 将第1～26行之间的所有文本复制到第82行的后面（可以选择行号）
使用可视化编辑器进行全局编辑
:s /target/replacement/ 查找当前行上目标字符串的第1个实例并删除，
然后用字符串replacement替换。只修改当前行上的第1个目标实例
:g /target/s//replacement/ 查找所有行上目标字符串的第1个实例并删除，
然后用字符串replacement替换。修改所有行上目标的第1个实例
:#,# s/target/replacement/ 在指定的行上进行替换。例如，:7,37 s/march/walk/将查找第7～37行之
间的所有文本行，并用字符串walk替换每行中的第1个目标字符串march。所有指定行上的第1个目标字符串修改
:#,# s/target/replacement/g 在指定的行上进行全局替换。例如，:1,$ s/fun/joyful/g 将在第1行到文件最
后一行之间查找目标字符串fun的所有实例并删除，然后用字符串joyful替换。指定行上的目标字符串的所有实例都被修改
:g /target/s/replacement 查找所有行上目标字符串的第1个实例并删除，
然后用字符串replacement替换。所有行上的第1个目标都被修改
:#,# target/s/replacement/ 在指定的行上进行替换，例如，:7,37 march/s/walk命令在第7～37行之间
每个文本行上查找目标字符串的第1个实例并删除，然后用字符串walk替换。所有指定行上的第1个目标字符串都被修改
:#,# target/s/replacement/g 在指定的行上进行全局替换。例如，:1,$ fun/s/joyful/g将在第1行到
文件最后一行之间查找目标字符串fun的所有实例并删除，然后用字符串joyful替换。指定行上的所有目标字符串都被修改

12.编辑工具：映射，缩写和标记
m# 用字母标记当前行。例如，ma命令表示用a标记当前行。即使移动了标记行，它仍然标记为a，可以用a来定位该行
'# 定位标记行。例如，命令'a将光标移到标记a的行。命令'a,$d将删除从标记行到文件末尾之间的所有行
:map # command string 在命令模式中输入＃时，将其作为一个命令串。例如，:map #o#!/bin/ksh产
生一个新的命令模式指令，您输入＃时，它被解释为:o打开个新行，并添加文本#!/bin/ksh到文件中。
为了在命令中包含回车和其他控制字符，可以在它们的前面用Ctrl+V命令
:ab abbreviation char-string 设置追加模式缩写。例如，在命令模式中输入:ab mv Milky Way Galaxy，
则建立缩写。如果在追加模式中输入字符串mw，然后按Esc键，mw将被Milky Way Galaxy替代

13.在vi编辑器中向shell发出命令
:!ls 启动一个shell，并让shell运行ls程序。在运行完指定的程序后，必须按回车键以返回到编辑器中
:!ksh 启动一个shell，它允许运行多个命令。退出shell可以回到编译器中
:Or!speel% 对当前文件(%)进行拼写检查，并将spell的输出诗篇到当前文件中，从第1行(0行后面)开始放置这些输出
:31r!command% 运行UNIX命令（如cal或date）并将它的输出读入到当前文件，从第31行开始放置这些输出
Ctrl+Z 用于挂起当前编辑会话进程的csh和ksh命令，它允许您向父shell发出命令
fg 重新激活挂起的编辑进程的csh和ksh命令

14.读、写和退出编辑器
:wq 保存编辑会话期间对文件所做的修改，退出编辑器返回到shell
:q 如果没有对文件进行修改或添加文件，可以用q退出对一个文件的编辑
:q! 退出对文件的编辑返回到shell模式，但是不保存在编辑会话期间对文件所做的修改
:w filename v将文件的缓冲区副本（修改版本）保存到一个新文件
[color=#DC143C][b]:#,# w newtest 例如，:1,6 w newtext命令创建一个名为newtext的文件，
并将当前文件的第1～6行文本复制到文件newtext中
:1,6 w >> oldfile 将当前文件的第1～6行文本的一个副本追加到已有文件oldfile的末尾
:1,6 w! oldfile 用当前文件的第1～6行文本覆盖文件oldfile

15.退出vi详解
　　当编辑完文件，准备退出Vi返回到shell时，可以使用以下几种方法之一。
　　在命令模式中，连按两次大写字母Z，若当前编辑的文件曾被修改过，则Vi保存该文件后退出，返回到shell；若当前编辑的文件没被修改过，则Vi直接退出, 返回到shell。
　　在末行模式下，输入命令　　:w
　　Vi保存当前编辑文件，但并不退出，而是继续等待用户输入命令。在使用w命令时，可以再给编辑文件起一个新的文件名。　　[例6]
　　:w newfile
　　此时Vi将把当前文件的内容保存到指定的newfile中，而原有文件保持不变。若newfile是一个已存在的文件，则Vi在显示窗口的状态行给出提示信息：
　　File exists (use ! to override)
　　此时，若用户真的希望用文件的当前内容替换newfile中原有内容，可使用命令
　　:w! newfile
　　否则可选择另外的文件名来保存当前文件。
　　在末行模式下，输入命令　　:q
　　系统退出Vi返回到shell。若在用此命令退出Vi时，编辑文件没有被保存，则Vi在显示窗口的最末行显示如下信息：
　　No write since last change (use ! to overrides)
　　提示用户该文件被修改后没有保存，然后Vi并不退出，继续等待用户命令。若用户就是不想保存被修改后的文件而要强行退出Vi时，可使用命令　　:q!
　　Vi放弃所作修改而直接退到shell下。
　　在末行模式下，输入命令　　:wq
　　Vi将先保存文件，然后退出Vi返回到shell。
　　在末行模式下，输入命令　　:x
　　该命令的功能同命令模式下的ZZ命令功能相同。

vi的一些操作
	dw 删除一个单词
	yw 复制一个单词
	D或d$ 删除到行尾
	d^删除到行首
	批量注释： ctrl + v 然后移动光标选行 再 输入大写I  # 再按esc
	多行删除：同上选中按d
	底行模式 X 加密   空格取消
	q! 撤销所有操作，还没保存
	替换：(底行模式)
		:%s/this/that/
		:%s/this/that/g
		:%s/this/that/gc
		:1,5s/this/that/gc
	noh 取消高亮 或查询找不到的
	:!ls 调用系统命令 或 :sh   用exit退出
	vimtutor  命令练习
	vi +N /etc/passwd
	Ngg  如：10gg
	打开多个文件：vi -O 文件1 文件2  切换 ctrl + ww
	自定义：
		在家目录创建 vim ~/.vimrc 文件添加以下内容
			set nu 	--显示行号
			set history=3 --历史命令个数
			syntax off   --语法加亮
	gedit a.txt & --后台运行gedit