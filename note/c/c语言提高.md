### 一、数组

#### 1.数组做函数参数退回问题

```c
void sort(int arr[8]);//arr使用时c当成指针使用
//退化
void sort(int *arr, int arr_len);
```



1.被实参和形参的数据类型不一样
2.形参中的数组C语言把它当作指针处理【这是c语言的特色，降低了形参的大小】
3.故需要把数组的首地址和长度传给被调用函数

### 二、数据类型

#### 1.为什么引入数据类型
1.数据类型可理解为创建变量的模具，是固定大小内存块的别名。
2.b和&b所代表的数据类型不一样
```
	int a =;//给我分配4个字节内存
	int b[10];//告诉编译器，给我分配40个字节内存
	// b代表数组首元素的地址 b+1跳4个字节
	// &b代表整个数组的地址 &b+1 跳40个字节
```
#### 2.对数据类型起别名
```
	typedef struct Test{
		ing age;
	}Test1;
	void main(){
		struct Test t1;//去掉struct报错
		Test1 t1;//这里不报错，这就是别名的区别
	}
```
### 三、零碎知识 

#### 1.变量
1.变量的本质
	程序通过变量来申请和命名内存空间
	通过变量名访问内存空间，一段连续的内存空间的别名，是一个门牌号
	对内存可读写，通过变量往内存中读写，不是向变量读写数据
2.变量修改内存的几种方式
```
	int a = 10;//直接修改
	*(int*)1245024) = 200;//间接修改==>通过内存地址，后面的数字是内存地址
	{
		char *p ;
		p = 1245024;
		*p = 300;//间接修改==>通过指针。把地址赋值给指针，通过*p间接修改内存内容。
	}
```
3.变量的三要素
	名称 大小 作用域
4.变量的生命周期
### 四、内存四区
#### 1.四区结构
	1.堆区
		malloc/new/free/delete 操作系统管理
		一般由程序员分配与释放，程序员不释放，程序结束时可能由操作系统回收。
	2.栈区
		程序局部变量
		由编译器自动分配释放，存放函数的参数值，局部变量的值等
		栈的开口方向，一般向下。
		char buf[64];//不管是开口向上，还是开口向下 buf+1 都比buf大
	3.全局区
		常量和全局变量，操作系统管理
		字符常量与其它常量的存储位置，程序结束后操作系统释放
	4.代码区
		操作系统管理。
	
		存放函数体的二进制代码
#### 2.示例
	```
		char *getNUm(){
			char buf[10];//临时变量存放在栈区，方法结束后释放，注意这里不是堆区
			strcpy(buf,"12345");
			return buf;
		}
	```
### 五、指针

#### 1.指针理解
	1.理解指针的的关键是内存，没有内存哪里来的指针
	2.指针指向谁就把谁的地址赋给指针
	3.c语言可以在栈上和堆上分配内存
	4.char buf[64];//不管是开口向上，还是开口向下 buf+1 都比buf大
	5.指针也是一种数据类型						
		指针的数据类型代表它向指向的内存空间的数据类型，指针步长根据所指向内存空间的数据类型来定
		指针是一种变量，占有内存空间，用来保存内存地址。4个字节。
		*p 在申明时，* 表示所申明的变量为指针
		*p 在使用时，* 表示操作指针向指向的内存空间的值
		*p 在左相当于往内存空间写值  *p = 10;
		*p 在右相当于从内在空间取值  int a = *P;
		*就像一把钥匙，通过一个地址(&a),去修改变量所指的内存空间
		不断的给指针赋值，相当于不断改变指针的指向,改变p只是改变了指针变量，不会改变内存p++ 和内存无关
		保证指针指向的内存可以被修改
			char *p = "abcde";//指向常量区，数据不能修改 *(p+2) = 'f';//报错
	6.指针做函数参数
		指针做函数参数时，多级指针
			站在编译器的角度，只需要分配4个字节的内存
			当我们使用时才关心指针指向的是一维还是二维
			指针做函数参数用n级指针改变n-1级指针的值
	7.避免出现野指针
		{
			int *p = NULL;
			p = "abcde";
			if( p != NULL){
				free(p);
				p = NULL://要写这句话，要不然会出现野指针，指针指向的内存空间释放了，但是指针的值没有变，还是指向那块无用的空间。
			}
		}
		避免：定义指针的时候指针赋值为NULL,释放内存的时候，指针赋值为NULL。
	8.通过改变指针遍历数组
		{
			char *p1 = NULL:
			p1 = (char *)malloc(100);
			strcpy(p1,"abcdef");
			char *p2 = NULL;
			for(int i = 0;i<10;i++){
				p1 = p2 +i;
				printf("%d",*p1);
			}
		}
	9.间接赋值的工程意义
		函数调用时，形参传给实参，用实参取地址，传给形参，在被调用函数中用*p，来改变实参，把运算结果给传出来。
	10.间接赋值的三个条件
		1.定义一个变量(实参)，定义一个变量(形参)
		2.建立关联，把实参取地址传递给形参
		3.通过形参间接修改实参的值
	11.不要把局部申请的内存传递到外部，方法执行完会加收。 *

#### 2.指针操作
	1.数组 
		1)C语言的字符串是以0结尾的字符串
		2)C语言中没有字符串类型，用字符数组模拟字符串
		3)字符串的内存分配，可以在堆，栈，全局区
	2.字符数组初始化
		1)
			//指定长度
			char buf[10] ={'a','b','c','d'};
			//char buf[2] ={'a','b','c','d'};//个数大于内存大小，报错
			//后面的buf[5]-buf[9] 置0
			//不指定长度，编译器会自动帮程序员求元素个数
			char buf1[] = {'a','b','c','d'} //不是一个以0结尾的字符串，只是一个字符数组
		2)用字符串初始化字符数组
			char buf[] = "abcd";//作为字符数组是5个字节，作为字符串是4个字节
			//strlen()求字符长度,不包括0
			//sizeof()内存块大小。求数组这个数据类型(固定大小内存块的别名)的大小。
		3)通过数组下标和指针操作数组
			int i = 0;
			char *p = NULL;
			char buf5[128] = "abcdef";
			for(i=0;i<strlen(buf5);i++){
				printf("%c",buf5[i]);
			}//通过数组下标 
			p = buf5;//buf5代表数组首元素的地址
			for(i=0;i<strlen(buf5);i++){
				printf("%c",*(p+i));
			}//通过指针
	3.[]的本质
		1.[]和*p是一样的，只不过是符合程序员的阅读习惯 buf5[i] ==>buf5[0+i] ==>*(buf5+i)
		2.buf5是一个指针，只读的常量，buf5是一个常量指针
		3.buf和指针的区别
			buf[20] = "abcd";//字符串常量初始化字符数组，这种方式可以修改内存
			在栈区buf[0] = a;buf[4] = '\0';内存分配在栈上
			*p = "efgh";// p是内存地址，指向常量字符串，这种方式不能通过指针修改内存
		4.推演 
			a[i] --> a[0+i] -> *(a+i)//a放到0，把中括号换小括号，在外面加*
	4.理解递归
		1.参数的入栈模型
		2.函数的嵌套调用
	5.步长
		int c[10] = {0};//编译时已经确定每个元素为0
		//对于一维数组c规定
		//1.c(数组名)是数组首元素地址 c+1步长为4
		//2.&c是整个数组地址 &c+1步长为10*4
		//3.数组首元素地址跟数组的地址值相等
	6.多维数组的本质
		int a[3][5];//a+1的步长 5*4 = 20字节 *
		//多维数组的本质是一个数组指针，步长是一维的长度
		//a+i代表整个第i行的地址 二级指针
		//*(a+i)代表第i行首元素地址 一级指针
		//*(a+i) +j ==>&a[i][j]
		//*(*(a+i)+j) ==> a[i][j] 元素值
	7.中括号推演
		a[i][j]  --> a[0+i][j] --> *(a+i)[j] -> *(a+i)[0+j] -> *(*(a+i)+j)
	8.二维数组做函数参数的退化
		void f(int a[5])==> void f(int a[]) ==> void f(int *a)
		void f(int a[3][3])==> void f(int a[][3]) ==> void f(int (*a)[3])
		等价关系：
			数组参数 				等效的指针参数
			一维数组：char a[30]	指针 char *a
			指针数组：char *a[30]	指针的指针 char **a  //**
			二维数组：char a[10][30] 数组的指针 char (*a)[30] //*

#### 3.二级指针

	画一下下面三种情况的内存模型
	{
		//指针数组，数组中的每个元素是指针
		int *myarr[] = {"aaaa","bbbb","cccc"};
		//二维数组
		char p[3][4] = {"aaaa","bbbb","cccc"};
		//手工二维内存
		char **p1 = (char **)malloc(3 * sizeof(char *));//int array[3];
		int i = 0;
		for(i=0;i<3;i++){
			p1[i] = (char *)malloc(10*sizeof(char *));//char buf[10];
		}
	}

### 六、const

#### 1.const基础：

	const int a;
	int const a ;//这两个一样，代表一个常整形数
	const char *c;//c是一个指向常整形数的指针，内存数据不能修改
	char * const c;char buf[10];//常指针，指针变量不能修改，内存可以修改
	const char * const e;//均不能修改
	看const是在*左边(修饰的是内存)还是右过(修饰的是指针)
	c语言中的const是冒牌货：
	const int a  = 10;
	a = 15;//报错
	int *p = &a;
	*p = 20;//此时a变为10


?	

#### 2.