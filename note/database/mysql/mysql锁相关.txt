一、事务
	1.mysql默认开启事务自动提交，如果要进行锁相关的操作需要关闭事务自动提交或使用begin开启一个事务。
	2.事务自动提交相关操作
		show variables like 'autocommit'; 	查看是否自动提交
		set autocommit=on; 					开启自动提交
		set autocommit=off;					关闭自动提交
二、锁相关
	1.为什么会出现锁
		我们在操作数据库的时候，可能会由于并发问题而引起的数据的不一致性（数据冲突），引用锁来解决这一问题。
	1.锁的分类
		[1]乐观锁
			乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。
			乐观锁不是数据库自带的，需要我们自己去实现.
			实现方式：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也通过增加时间戳的方式实现。
			select (id,status,version) from user where id=#{id}
			update user set status=2,version=version+1 where id=#{id} and version=#{version};
		[2]悲观锁
			1.在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟java中的synchronized很相似，所以悲观锁需要耗费较多的时间。
			2.悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。
			3.共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。
			4.共享锁又称为读锁，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
			5.排他锁又称为写锁，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。
			6.共享锁 
				SELECT * from city where id = "1"  lock in share mode; 其他事务可在共享锁下读
			7.排它锁
				SELECT * from city where id = "1" for update;  其它事务不可在排他锁下读
			8.无锁
				SELECT * from city where id = "1";   这种查询在共享锁和排他锁下都可读
			9.对于update，insert，delete无法手动加共享锁和排他锁，mysql默认加排他锁
三、数据引擎
	1.mysql常用数据引擎有MyISAM和InnoDB
	2.设置
		1)
			CREATE TABLE `city` (
			  `id` bigint(20) NOT NULL AUTO_INCREMENT,
			  `name` varchar(255) DEFAULT NULL,
			  `state` varchar(255) DEFAULT NULL,
			  PRIMARY KEY (`id`)
			) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8;
		2)
			alter table tablename type=innodb
	3.主要区别
		1).MyISAM是非事务安全型的，而InnoDB是事务安全型的。
		2).MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
		3).MyISAM支持全文类型索引，而InnoDB不支持全文索引。
		4).MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。
		5).MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。
		6).InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。
	4.应用场景：
		1).MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
		2).InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。
	5. InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题.
				