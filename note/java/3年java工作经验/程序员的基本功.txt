一、数组与内存控制
1.数组用于存储多个类型相同的变量
2.java数组是静态的，即当数组初始化后，数组的长度是不可变的。
3.数组必须初始化后才可使用
4.数组初始化两种方式
	a)静态初始化[显示指定初始化，系统决定数组长度]
	b)动态初始化[显示指定长度，系统分配初始值]
5.java的数组是静态的，一旦初始化完成，数组元素的内存空间分配即结束，只能改变元素值，不能改变长度。
6.数组变量是一种引用类型的变量，改变引用，只是表面上改变了数组长度，实质没改变。
7.使用数组前必须先进行初始化，说的是数组对象，而不是数组变量，数组变量可不先初始化。
8.数组变量是数组对象的一个引用，存放在栈中，数组对象存放在堆中。
9.数组元素就是变量
10.没有多维数组，二维数组实质是数组元素为一维数组的一维数组。
11.数组的length属性，返回系统为该数组分配的连续内存空间的长度。
二、对象与内存控制
1.java内存管理分为两个方面内存分配和内存回收
2.程序对实例变量的初始化
 1)定义实例变量时指初始化
 2)构造代码块中初始化
 3)构造函数中初始化
 1,2的执行顺序与它们在源程序中的顺序相同，但都早于构造函数。
3.程序对类变量的初始化
 1)定义类变量时初始化
 2)静态代码块中初始化
 1,2的执行顺序与它们在源程序中的顺序相同。
4.父类构造器调用被子类重写过的父类的方法时，会执行子类重写的方法，这时各成员变量有可能还只处于默认初始化阶段。
5.被final修饰的变量，如果其值在编译期能够被确定下来,那么该变量将会被当成宏变量，也就是在所有出现该变量的地方系统把它当成对应的值处理。
6.被final修饰的变量，赋初值，可以是直接量或算术表达式。
7.对于final实例变量而言，只有在定义该变量时指定初始化才会有"宏变量"的效果。在构造代码块，构造函数是给final变量赋初始值，则无此效果。
三、常见java集合
1.Set和Map
	Set代表一种无序，不重复的集合。
	Map代表一种由多个key-value对组成的集合。
2.Set和Map的关系
	Map集合可以说是Set集合的扩展，java中Map集合的继承体系与Set很相似。
	Map集合的key集中起来就构成了一个Set集合。
	定义一个key-value实体类可以把set扩展成Map，把key-value捆绑在一起对待。
3.集合中号称是存储的java对象，实际上存储的是这些对象的引用。这些引用指向实际的java对象。同引用类型的数组。
4.HashMap的负载因子，默认值为0.75，这是时间和空间成本上的一种折衷。
	增大负载因子可以减小Hash表所占用的内在空间。但会增加查询数据的时间开销，
	减小负载因子会提高数据查询的性能，但会增加Hash表所占用的空间。
5.HashSet只是封装了一个HashMap对象来存储所有的集合元素所有存入HashSet的集合元素实际由HashMap的key来保存，value则存储了一个静态的Object对象。
6.HashSet存入对象，先判断hashCode是否相等，如果相等再比较equalse是否相等。
7.TreeSet底层依赖TreeMap[采用“红黑树”的排序二叉树来保存每个Entry]实现，因此其key总是由小到大排列。TreeMap效率比HashMap低。
8.TreeSet排序两种方式，一让元素自身具备比较性（实现Comparabler接口覆盖compareTo方法），二传入比较器，实现Comparator接口实现compare方法，两个都存在时以比较器为主。
9.Map和List的关系
	Map和List在实现在并没有联系，只是在用法上相似，可以看成List相当于所有key是int类型的Map，Map相当于索引是任意类型的List。
九、线性表
1.IT到底是I重要还是T重要，I重要，I代表IT的终极目标Information(信息),而T(Technology)只是存储和管理信息的手段。
2.应用程序中的数据结构大致有如下4类基本逻辑结构.
	集合：数据元素之间只有"同属于一个集合"关系。
	线性结构：数据元素之间存在一个对一个的关系。
	树形结构：数据元素之间存在一个对多个的关系。
	图状或网状结构：数据元素之间存在多个对多个的关系。
3.对于数据不同的逻辑结构，计算机在物理磁盘上通常有2种物理存储结构。
	顺序存储结构：用一组地址连续的存储单元依次存放线性表的元素。loc(ai) = loc(a0) + i*b(0<i<n) b代表数据元素的存储单元
	链式存储结构：用一组地址任意的存储单元存放线性表中的元素(单向链表，双向链表，循环链表)
4.线性表与数组
  线性表长度可以动态改变，但java数组的长度是固定的。
  线性表可以插入删除元素，数组不可以，只能将元素赋值null，但各元素依然存在
5.LinkedList是双向链表
十、栈和队列
1.栈是一种后进先出的线性表(LIFO)[只能在某一端插入和删除元素，通常是尾端].
2.栈有顺序栈和链栈
3.java中的栈
 Stack 顺序栈，低层基于数组实现是线程安全的。
 LinkedList 链栈，线程不安全。
4.队列是一种先进先出的线性表(FIFO)[只允许在前端删除元素，在后端插入元素].
5.队列
	顺序队列，采用数组保存队列元素，队列会满
	循环队列，可解决队列假满问题
	链队列，允许添加无限多个元素，无队列满问题
6.java中的队列
	Queue接口
	ArrayBlockingQueue顺序队列
	LinkedBlockingQueue链队列
	ConcurrentLinkedQueue链队列
7.双向队列，可在两端同时进行插入删除操作
8.java提供的双向队列
 Deque接口
 ArrayDeque顺序存储双端队列
 LikndeBlokingDeque链式存储的双端队列
 LinkedList链式存储的双端队列
 LinkedList是双向链式结构的循环线性表，也是链式结构的双向队列。
9.jdk不推荐使用Stack，推荐使用Deque作为栈使用