一、Java技术体系包括
1.Java程序设计语言
2.各种硬件平台上的Java虚拟机
3.Class文件格式
4.Java API类库
5.来自商业机构和开源社区的第三方Java类库
二、JDK
我们可以把Java程序设计语言、Java虚拟机、Java  API类库这三部分统称为JDK（Java
Development  Kit），JDK是用于支持Java程序开发的最小环境
三、JRE
Java  API类库中的Java SE API子集和Java虚拟机这两部分统称为
JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境
四、java虚拟机所管理的内存
程序计数器：
	是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的
字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需
要依赖这个计数器来完成
	每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，
	独立存储，我们称这类内存区域为“线程私有”的内存。
java虚拟机栈：
与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）
也是线程私有的，它的
生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时
都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口
等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出
栈的过程。
	局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、
float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对
象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和
returnAddress类型（指向了一条字节码指令的地址）。
	在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚
拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如
果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
本地方法栈：
	本地方法栈（Native  Method  Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间
的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚
拟机使用到的Native方法服务。甚至有的虚拟机（譬如Sun HotSpot虚拟机）
直接就把本地方法栈和虚拟机栈合二为一
java堆：
	Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就
是存放对象实例，几乎所有的对象实例都在这里分配内存。
	Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可
方法区：
	同Java堆一样，是各个线程共享的内存区域，它用于存储已被虚
拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
	Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，
还可以选择不实现垃圾收集。
运行时常量池：
	运行时常量池（Runtime  Constant  Pool）是方法区的一部分。Class文件中除了有类的版
本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于
存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常
量池中存放。
五、对象的创建
	虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一
个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没
有，那必须先执行相应的类加载过程。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类
加载完成后便可完全确定
六、对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、
实例数据（Instance Data）和对齐填充（Padding）
七、GC需要完成的3件事情：
哪些内存需要回收？
什么时候回收？
如何回收？
八、生命周期
程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭
九、引用计数器法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；
当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再
被使用的。但主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象
之间相互循环引用的问题。
十、可达性分析算法
这个算法的基本思
路就是通过一系列的称为“GC  Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所
走过的路径称为引用链（Reference  Chain），当一个对象到GC  Roots没有任何引用链相连
（用图论的话来说，就是从GC  Roots到这个对象不可达）时，则证明此对象是不可用的。
十一、在Java语言中，可作为GC Roots的对象包括下面几种：
虚拟机栈（栈帧中的本地变量表）中引用的对象。
方法区中类静态属性引用的对象。
方法区中常量引用的对象。
十二、引用分为
强引用（StrongReference）、Object  obj=new  Object（）。
	只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
软引用（Soft  Reference）、SoftReference类来实现软引用。
	在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回
收还没有足够的内存，才会抛出内存溢出异常。
弱引用（Weak  Reference）、WeakReference类来实现弱引用。	
	当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
虚引用（PhantomReference），PhantomReference类来实现虚引用。
	设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
十三、永久代的垃圾收集主要回收两部分内容：
废弃常量和无用的类。
十四、判断无用的类
该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
加载该类的ClassLoader已经被回收。
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该
类的方法。
十五、垃圾回收算法
1.标记清除算法
	首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
	缺点：一个是效率问题，标记和清除两个过程的效率都不高；另一个是
空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程
序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾
收集动作。
2.复制算法
	它将可用内存按容
量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着
的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
	缺点：这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。
3.标记-整理算法
	标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，
而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
4.分代收集算法
	一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，
只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、
没有额外空间对它进行分配担保，就必须使用“标记―清理”或者“标记―整理”
算法来进行回收。
十六、HotSpot虚拟机如何去发起内存回收
1.安全点
	只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时
并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。
2.安全区（线程处理sleep或blocked时无法响应JVM的中断请求）
	全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方
开始GC都是安全的。
十七、HotSpot中的垃圾收集器
1.Serial收集器
	这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一
个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，
必须暂停其他所有的工作线程，直到它收集结束。
2.ParNew收集器
	ParNew收集器其实就是Serial收集器的多线程版本
3.Parallel Scavenge收集器（自适应调节策略也）
	Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行
的多线程收集器
4.Serial Old收集器（使用“标记-整理”算法）
	一种用途是在JDK1.5以及之前的版本中与Parallel  Scavenge收集器搭配使用，
另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode  Failure时使用。
5.Parallel Old收集器（多线程和“标记-整理”算法）
6.CMS收集器（以获取最短回收停顿时间为目标的收集器。）【并发收集、低停顿】
	基于“标记―清除”算法：
	初始标记（CMS initial mark）
	并发标记（CMS concurrent mark）
	重新标记（CMS remark）
	并发清除（CMS concurrent sweep）
7.G1收集器
与其他GC收集器相比，G1具备如下特点：
1.并行与并发
2.分代收集
3.空间整合
4.可预测的停顿

G1收集器的运作：
初始标记（Initial Marking）
并发标记（Concurrent Marking）
最终标记（Final Marking）
筛选回收（Live Data Counting and Evacuation）
十八、长期存活的对象将进入老年代
	虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor  GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次MinorC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置
十九、动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到
了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总
和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等
到MaxTenuringThreshold中要求的年龄。


JAVA工具命令：
1.jps 虚拟机进状况工具(列出正在运行的虚拟机进程，并显示虚拟机执行主类)
  -q 只输出LVMID，省略主类的名称
  -m 输出虚拟机启动时传递给主类的参数
  -l 输出主类的全名，如果进程执行的是jar包，输出jar路径
  -v 输出虚拟机进程启动时JVM参数
2.jstat 虚拟机统计信息监视工具(监视虚拟机各种运行状态信息)
  格式：jstat[option vmid[interval[s|ms][count]]]
  远程：[protocol：][//]lvmid[@hostname[：port]/servername]
  jstat-gc 2764 250 20  :每250毫秒查询一次进程2764垃圾收集状况，一共查询20次：
3.jinfo：Java配置信息工具(实时地查看和调整虚拟机各项参数)
	jinfo -sysprops 4816 虚拟机进程的System.getProperties（）的内容打印出来
	jinfo -flag [+|-]name或者-flag  name=value修改一部分运行期可写的虚拟机参数值。
4.jmap：Java内存映像工具(jmap：Java内存映像工具)
	jmap -dump:format=b,file=C:\kuaizhao.bin 4816 转存快照
	其它方式拿快照：
	第2章中用过的-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出
现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]
键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一
下虚拟机，也能拿到dump文件
5.jhat：虚拟机堆转储快照分析工具
	jhat c:\kuaizhao.bin 
	浏览器输入：http://localhost：7000/
6.jstack：Java堆栈跟踪工具(生成虚拟机当前时刻的线程快照)
	-F 当正常输出的请求不被响应时，强制输出线程无依堆栈
	-l 除堆栈外，显示关于锁的附加信息
	-m 如果调用到本地方法的话，可以显示C\C++的堆栈
7.故障处理工具
	jconsole，VisualVM（官方）
	JProfiler、YourKit（非官方）

类文件结构：
1.Class文件格式
采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表
无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个
字节和8个字节的无符号数
表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地
以“_info”结尾
格式
类型			名称				 	数量			      	作用	
u4				magic					1 						(魔数)确定这个文件是否为一个能被虚拟机接受的Class文件(很多文件都使用魔数进行身份识别，主要地基于安全方面的考虑)0xCAFEBABE（咖啡宝贝）
u2				minor_version			1						次版本号
u2				major_version			1						主版本号
u2				constant_pool_count		1						常量池入口Class
文件结构中只有常量池的容量计数是从1开始，常量池主要存放：字面量和符号引用
cp_info			constant_pool 			constant_pool_count-1 	
u2				access_flags			1						访问标志
u2				this_class				1						类索引
u2				super_class				1						父类索引
u2				interface_count			1						接口索引
u2				interfaces				interface_count			接口索引集合
u2				fields_count			1						字段表，描述
接口或类中申明的变量
field_info		fields					fields_count			额外信息
u2				methods_count			1						方法表
method_info		methods 				methods_count			
u2				attributes_count        1						属性表集合
attribute_info	attributes 				attributes_count
2.分析class文件字节码工具
javap -verbose TestClass

一、虚拟机类加载机制
1.虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始
化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
2.Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的
3.这种策略虽然会令类加载时稍微增加一些性能开销但是会为Java应用程序提供高度的灵活性
4.Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
二、类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：
加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段
其中验证、准备、解析3个部分统称为连接（Linking）
三、5种情况必须对类进行初始化（加载、验证、准备自然需要在此之前开始）
1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初
始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字
实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常
量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，
则需要先触发其初始化。
3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父
类的初始化。
4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个
类），虚拟机会先初始化这个主类。
5）当使用JDK  1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后
的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。
四、类的初始化
1.通过子类引用父类的静态字段，不会导致子类初始化
2.通过数组定义来引用类，不会触发此类的初始化
3常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
五、当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。
六、过程
1.加载：在加载阶段，虚拟机需要完成以下3件事情：
1）通过一个类的全限定名来获取定义此类的二进制字节流。
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据
的访问入口。
数组可见性:数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。
加载之后会在内存中实例化一个java.lang.Class，存放在方法区中，程序访问方法区中数据类型的外部接口
2.验证
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息
符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
3.准备
这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。
4.解析
1)类或接口的解析
2)字段解析
3)类方法解析
4)接口方法解析
5.初始化

七、类与类加载器
1.类加载器
比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。
2.双亲委派模型
从Java虚拟机的角度来讲，只存在两种不同的类加载器：
启动类加载器（Bootstrap  ClassLoader）[C++实现，属于虚拟机的一部分]
其他的类加载器全都继承自抽象类java.lang.ClassLoader[JAVA语言实现，虚拟机外部]
从开发人员角度到讲，有三种系统提供的类加载器：
启动类加载器（Bootstrap ClassLoader）[加载~\lib下，并被虚拟机识别的类,不可直接调用]
扩展类加载器（Extension  ClassLoader）[加载~\lib\ext下,可直接调用]
应用程序类加载器（Application ClassLoader）[加载ClassPath下,可直接调用]
类加载器双亲委派模型:启动类加载器->扩展类加载器->应用程序类加载器->自定义类加载器
规则：
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。
加载：
自己先不加载委派给父类加载器加载(每一层都这样)，父反馈加载不了，才由子类尝试加载
八、虚拟机字节点执行引擎
1.运行进栈帧结构
是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual  Machine  Stack）的栈元素
存储：方法的局部变量表、操作数栈、动态连接和方法返回地址等信息
大小：一个栈帧需要分配多少内存在编译时就能确定不会受运行期变量数据影响
当前栈帧：在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与之关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。
1）局部变量表
用于存放方法参数和方法内部定义的局部变量(编译时可确定变量表的最大容量)
以变量槽(Slot)为最小单位
2）操作数栈
操作栈，后入先出，同局部变量表一样最大深度在编译时写入Code属性的max_stacks中
3）动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为
了支持方法调用过程中的动态连接
4）方法返回地址
方法执行后只有两种方式退出这个方法：
遇到方法返回字节码指令(可能会有返回值返回给调用者)
方法执行时遇到了异常，并且没有在方法体中处理(不会给调用者产生返回值)
无论哪种方式退出，方法退出之后都需要返回到方法调用的位置。
2.方法调用
方法调用不同于方法执行，方法调用阶段唯一的任务就是确定被调用的是哪一个方法。
一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行
时内存布局中的入口地址
1）解析
在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。
运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类
2）5条方法调用字节码指令
invokestatic：调用静态方法。
invokespecial：调用实例构造器＜init＞方法、私有方法和父类方法。
invokevirtual：调用所有的虚方法。
invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。
invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的
javap -verbose HelloWorld.class(查看字节码)
3）分派（方法重载。编译阶段）
所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。
静态方法也可以有重载版本(方法)，而选择重载版本也是通过静态分派来完成的
4）动态分派（方法重写，运行阶段）
在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
5）单分派与多分派
至今的Java语言是一门静态多分派、动态单分派的语言。