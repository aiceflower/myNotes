一、Java技术体系包括
1.Java程序设计语言
2.各种硬件平台上的Java虚拟机
3.Class文件格式
4.Java API类库
5.来自商业机构和开源社区的第三方Java类库
二、JDK
我们可以把Java程序设计语言、Java虚拟机、Java  API类库这三部分统称为JDK（Java
Development  Kit），JDK是用于支持Java程序开发的最小环境
三、JRE
Java  API类库中的Java SE API子集和Java虚拟机这两部分统称为
JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境
四、java虚拟机所管理的内存
程序计数器：
	是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的
字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需
要依赖这个计数器来完成
	每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，
	独立存储，我们称这类内存区域为“线程私有”的内存。
java虚拟机栈：
与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）
也是线程私有的，它的
生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时
都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口
等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出
栈的过程。
	局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、
float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对
象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和
returnAddress类型（指向了一条字节码指令的地址）。
	在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚
拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如
果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
本地方法栈：
	本地方法栈（Native  Method  Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间
的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚
拟机使用到的Native方法服务。甚至有的虚拟机（譬如Sun HotSpot虚拟机）
直接就把本地方法栈和虚拟机栈合二为一
java堆：
	Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就
是存放对象实例，几乎所有的对象实例都在这里分配内存。
	Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可
方法区：
	同Java堆一样，是各个线程共享的内存区域，它用于存储已被虚
拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
	Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，
还可以选择不实现垃圾收集。
运行时常量池：
	运行时常量池（Runtime  Constant  Pool）是方法区的一部分。Class文件中除了有类的版
本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于
存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常
量池中存放。
五、对象的创建
	虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一
个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没
有，那必须先执行相应的类加载过程。在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类
加载完成后便可完全确定
六、对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、
实例数据（Instance Data）和对齐填充（Padding）
七、GC需要完成的3件事情：
哪些内存需要回收？
什么时候回收？
如何回收？
八、生命周期
程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭
九、引用计数器法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；
当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再
被使用的。但主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象
之间相互循环引用的问题。
十、可达性分析算法
这个算法的基本思
路就是通过一系列的称为“GC  Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所
走过的路径称为引用链（Reference  Chain），当一个对象到GC  Roots没有任何引用链相连
（用图论的话来说，就是从GC  Roots到这个对象不可达）时，则证明此对象是不可用的。
十一、在Java语言中，可作为GC Roots的对象包括下面几种：
虚拟机栈（栈帧中的本地变量表）中引用的对象。
方法区中类静态属性引用的对象。
方法区中常量引用的对象。
十二、引用分为
强引用（StrongReference）、Object  obj=new  Object（）。
	只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
软引用（Soft  Reference）、SoftReference类来实现软引用。
	在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回
收还没有足够的内存，才会抛出内存溢出异常。
弱引用（Weak  Reference）、WeakReference类来实现弱引用。	
	当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
虚引用（PhantomReference），PhantomReference类来实现虚引用。
	设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
十三、永久代的垃圾收集主要回收两部分内容：
废弃常量和无用的类。
十四、判断无用的类
该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
加载该类的ClassLoader已经被回收。
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该
类的方法。
十五、垃圾回收算法
1.标记清除算法
	首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象
	缺点：一个是效率问题，标记和清除两个过程的效率都不高；另一个是
空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程
序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾
收集动作。
2.复制算法
	它将可用内存按容
量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着
的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
	缺点：这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。
3.标记-整理算法
	标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，
而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
4.分代收集算法
	一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，
只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、
没有额外空间对它进行分配担保，就必须使用“标记―清理”或者“标记―整理”
算法来进行回收。
十六、HotSpot虚拟机如何去发起内存回收
1.安全点
	只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时
并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。
2.安全区（线程处理sleep或blocked时无法响应JVM的中断请求）
	全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方
开始GC都是安全的。
十七、HotSpot中的垃圾收集器
1.Serial收集器
	这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一
个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，
必须暂停其他所有的工作线程，直到它收集结束。
2.ParNew收集器
	ParNew收集器其实就是Serial收集器的多线程版本
3.Parallel Scavenge收集器（自适应调节策略也）
	Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行
的多线程收集器
4.Serial Old收集器（使用“标记-整理”算法）
	一种用途是在JDK1.5以及之前的版本中与Parallel  Scavenge收集器搭配使用，
另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode  Failure时使用。
5.Parallel Old收集器（多线程和“标记-整理”算法）
6.CMS收集器（以获取最短回收停顿时间为目标的收集器。）【并发收集、低停顿】
	基于“标记―清除”算法：
	初始标记（CMS initial mark）
	并发标记（CMS concurrent mark）
	重新标记（CMS remark）
	并发清除（CMS concurrent sweep）
7.G1收集器
与其他GC收集器相比，G1具备如下特点：
1.并行与并发
2.分代收集
3.空间整合
4.可预测的停顿

G1收集器的运作：
初始标记（Initial Marking）
并发标记（Concurrent Marking）
最终标记（Final Marking）
筛选回收（Live Data Counting and Evacuation）
十八、长期存活的对象将进入老年代
	虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor  GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次MinorC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置
十九、动态对象年龄判定
为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到
了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总
和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等
到MaxTenuringThreshold中要求的年龄。