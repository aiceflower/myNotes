一、java虚拟机的组成部分
1.类加载子系统
负责从文件系统或网络中加载Class信息，加载的信息放在方法区的内存空间
2.方法区
存放类信息，常量信息，常量池信息，包括字符串字面量和数字常量等
3.java堆
在java虚拟机启动的时候创建java堆，它是java程序最主要的内存工作区域，
几乎所有的对象实例都放到java堆中，堆空间是所有线程共享的
4.直接内存
java的NIO库允许java程序使用直接内存，从而提高性能，通常直接内存性能会高于java堆，读写频繁的地方可以考虑使用。
5.栈
每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建的时候被创建，java栈保存者局部变量，方法参数，java的方法调用，返回值等。
6.本地方法栈
与java栈非常相似，最大的不同为本地方法栈用于本地方法的调用，java虚拟机允许java直接调用本地方法(通常由C编写)
7.垃圾收集系统
java的核心也是必不可少的，java有一套自己的垃圾清理机制，开发人员无须手工清理
8.PC(Program Counter)寄存器也是每个线程私有的空间，java虚拟机会为每个线程创建PC寄存器，在任意时刻，一个java线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法为是本地方法，PC寄存器就会执行当前正在被执行的命令，如果是本地方法，则PC寄存器值为undefined,寄存器存放，执行环境指针，程序计数器，操作栈指针，计算的变量指针等信息。
9.执行引擎
最核心的组件，负责执行java虚拟机字节码，一般用户先进行编译成机器码后执行。
二、堆，栈，方法区的概念与联系
堆：解决的是数据存储的问题，即数据怎么放，放在哪儿
栈：解决的是程序运行的问题，即程序如何执行，或者说如何处理数据
方法区：辅助堆栈的块永久区(perm),解决堆栈信息的产生，是先决条件，创建一个对象时，对象的类信息，静态信息都存放在方法区中
二、二：堆的组成
	新生代：
		eden:刚创建的新对象
		from/to：大小相等并且可以互换角色的空间
		在一次新生代回收后，如果对象还存活则回进入from或to区，之后每次回收对象的"年龄"加一，到一定阀值(默认为15)，后对象进入到老年代。
		from和to区对象采用复制算法
	老年代：
三、java栈组成
局部变量表：用于报错函数的参数及局部变量
操作数栈：存放计算过程的中间结果，同时作为计算过程中变量临时的存储空间
帧数据区：除了局部变量表和操作数栈以外，栈还需要一些数据来支持常量池的解析，这里帧数据区保存者访问常量池的指针，方便程序访问常量池，另外当函数返回或出现异常时，虚拟机必须有一个异常处理表，方便发生异常的时候能找到异常的代码，因此异常处理表也是帧数据区的一部分。
三、二：方法区：
	方法区和堆一样是一块所有线程共享的内在区域，它保存系统的类信息，如类的字段，方法，常量池等。
	方法区的大小决定了系统可以保存多少个类。如果系统定义太多的类，导致方法区溢出，虚拟机会抛出内在溢出的错误。
	方法区可理解为永久区。(perm)
四、配置参数
0.输出gc log到文件
-Xloggc:d:/gc.log
1.堆分配参数
-XX:+PrintGC 使用这个参数，只要发生GC的时候就会打印日志
-XX:+UseSerialGC 配置串行回收器
-XX:+PrintGCDetails 可查看详细信息，包括各个区的情况
-Xms: 设置java程序启动进初始堆大小
-Xmx: 设置java程序能获得的最大堆大小
-XX:+PrintCommandLineFlags 打印虚拟机的配置参数
2.新生代配置
-Xmn: 设置新生代大小，这个参数对系统性能及GC行为有很大影响，一般设置为整个堆的1/3,1/4
-XX:SurvivorRatio: 设置新生代中from区和to区的空间的比例为eden/from或eden/to
-XX:NewRatio: 老年代比上新生代
3.栈配置
-Xss1m 指定线程的最大栈空间，直接决定函数可调用的最大深度。
4.方法区配置
-XX:PermSize=64M,默认为64M
5.直接内存配置
-XX:MaxDirectMemorySize,如果为配置则为最大堆空间，即-Xmx
-XX:MaxPermSize=64M
6.从新生代到老年代次数
-XX:MaxTenuringThreshold=15
7.新生代装不下大对象的时候会直接进入老年代
-XX:PretenureSizeTheshold=10240
8.对于数据不太大的元素jvm默认会分配到TLAB区，因此失去了老年代的分配机会(与6相对应，比如设置大小为1k)，TLAB[线程本地分配缓存]
-XX:-UseTLAB  [-代表不使用TLAB区，默认是使用的]
-XX:+TLABSize
-XX:+PrintTLAB 打印TLAB区信息
java创建对象分配：
先到栈-->失败到TLAB区-->失败到老年代-->失败到新生代
9.垃圾回收方式
串行：
-XX:+UseSerialGC 配置串行回收器
并行：
-XX:+UseParNewGC [新生代ParNew回收器]
-XX:+UseAdaptiveSizePolicy[打开自适应，新生代ParalleGC回收器，利用了复制算法，关注系统的吞吐量]
-XX:+UseParalleOldGC[老年代回收器，关注吞吐量，利用了标记压缩算法]
配置并行线程数量：
-XX:ParallelGCThreads=3
-XX:UseConcMarkSweepGC[CMS回收器，并发标记清除，选用标记清除算法，关注系统停顿时间]
-XX:ConcGCThreads=3[设置CMS并发线程数量]
-XX:CMSInitatingOccupancyFraction [指定CMS开始回收阀值，默认为68当选用率到68%的时候回收]
注：CMS一边程序运行着，一边垃圾回收着，一但内存不足，则回收完毕程序才能继续运行。
-XX:UseG1GG [G1回收器]
-XX:MaxGCPauseMillis[指定最大停顿时间]
-XX:ParallelGCThreads=3[配置线程数量]
五、内存分析工具
Memory Analyzer 1.5.0
http://download.eclipse.org/mat/1.5/update-site/
六、虚拟机工作模式
client模式和server模式
client模式，启动速度快，性能慢
server模式，启动速度慢，性能快
在jdk1.7后基本都是server模式
七、垃圾收集算法
1.引用计数法，引用为0时回收，无法解决循环引用问题
2.标记清除算法，有空间碎片问题，工作效率低。
3.复制算法：次内存空间分为两块，每次只使用其中一决，将还需要使用的对象转移到未使用的那一决，然后将这一次全部清除。
4.标记压缩算法：先使用标记清徐算法，然后再将存活的对象压缩到内存的一端。
新生代采用复制算法，老年代采用标记压缩算法
为什么新生代老年代采用不同的算法:回收对象的数量和次数不一样
八、常用的垃圾收集器
串行回收器
并行回收器:复制算法，关注吞吐量
CMS回收器：并发标记清除算法，关注系统停顿【产生新的垃圾，一致性】时间，GC时程序仍然工作。
G1回收器:分区的思想
九：查看加载类
	java -verbose HelloWorld
--------------------------------------
ClassLoader是jdk的一种安全机制
jdk认为程序安全是他的事，文件安全是系统的事。
自己写一个java.util.List.java,里面的main方法是不能执行的，但可以编译。 
java夸平台说的是 Write Once,Run Anywhere ,操作系统对应的操作指令不同，但是不同的jvm把相同的指定（如system.out.print()）解释成了对应操作系统的指令。
1.为什么要学jvm
	1.它帮你做了内存管理（专注于写业务就可以了）
	2.它是夸平台的，Write Once,Run Anywhere
	3.出问题的时候可以解决问题
2.程序是由数据，指令，控制组成的
3.jvm运行时数据区
	指令：
		程序计数器【线程独享】：指向当前线程正在执行的字节码指令的地址行号
			线程是程序的最小单元，为什么还需要程序计数器：
				1.cpu运行要抢占时间片，被打断后，回来的时候需要知道执行在哪里
				2.控制需要程序计数器
		虚拟机栈【线程独享】：存储当前线程运行方法所需要的数据、指令、返回地址
			出栈，入栈的元素是栈帧
				栈帧：
					局部变量表：存储局部变量的表，在编译时可确定大小。
					操作数栈：javap 命令可查看，如int i = 0;存入在操作数栈中，即把需要操作的数压入栈
					动态链接：service.do();写的是接口，但实际运行时是实现类，这个是动态链接的工作
					出口：返回地址
				一个方法调用另一个方法的时候方法一先入栈，然后方法二再入栈，这时的方法一，方法二都是一个栈帧。
		本地方法栈【线程独享】:同虚拟机栈，只不过是存储本地方法所需要的数据。。。
	数据：
		方法区【永久代1.8以前在方法区】：类信息，常量，静态变量 
		1.8以后永久代不在方法区，用metaspace【可扩容】代替，解决永久代溢出问题。
		堆：
			新生代：
			老年代：
		为什么会分代：空间利用率，和垃圾回收
		新:老:永 = 8:1:1