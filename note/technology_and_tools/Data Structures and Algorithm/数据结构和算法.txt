1.数据的存储结构
	传统上，我们把数据结构分为
	逻辑结构：是指数据对象中数据元素之间的相互关系
	物理结构：是指数据的逻辑结构在计算机中的存储形式。
2.四大逻辑结构
	集合结构：同属于一个集合
	线性结构：一对一关系
	树形结构：一对多关系
	图形结构：多对多关系
2.1线性表的存储结构
	顺序存储：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。
	链式存储：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。
3.算法的的特性
 输入
 输出
 有穷性
 确定性
 可行性
4.算法设计的要求
 正确性
 可读性
 健壮性
 时间效率高和存储量低
5.算法效率的度量方法
	事后统计方法
	事前分析估算方法
6.计算机上运行时所消耗的时间取决于下列因素
	1. 算法采用的策略，方案
	2. 编译产生的代码质量
	3. 问题的输入规模
	4. 机器执行指令的速度
7.常用时间复杂度的关系
O(1)<O(logn)<O(n)<O(nlogn) <O(n2)<O(n3)
指数时间的关系为：
 O(2n)<O(n!)<O(nn)	
8.通常，我们都是用“时间复杂度”来指运行时间的需求，是用“空间复杂度”指空间需求。
9.线性表
	线性表（List）：由零个或多个数据元素组成的有限序列。
	1.首先它是一个序列，也就是说元素之间是有个先来后到的
	2.若元素存在多个，则第一个元素无前驱，而最后一个元素无后继，其他元素都有且只有一个前驱和后继。
	3.另外，线性表强调是有限的，事实上无论计算机发展到多强大，它所处理的元素都是有限的。	
	4.ai领先于ai+1,称ai-1是ai的直接前驱元素,ai+1是ai的直接后继元素。
	5.所以线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，称为空表。
10.例如在C语言中，按照取值的不同，数据类型可以分为两类：
原子类型：不可以再分解的基本类型，例如整型、浮点型、字符型等。
结构类型：由若干个类型组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的。
11.抽象数据类型（Abstract Data Type，ADT）
12.线性表的顺序存储结构
	封装顺序存储结构需要三个属性：
	存储空间的起始位置
	线性表的最大存储容量
	线性表的当前长度
13.么线性表中第i+1个数据元素和第i个数据元素的存储位置的关系是
	LOC(ai+1) = LOC(ai) + c
14.线性表的顺序存储结构在存，读数据时时间复杂度为O(1),在插入和删除时时间复杂度为O(n)
15.线性表的顺序存储结构的优缺点
	优点：
		无须为表示表中元素之间的逻辑关系而增加额外的存储空间。
		可以快速地存取表中任意位置的元素。
	缺点：
		插入和删除操作需要移动大量元素。
		当线性表长度变化较大时，难以确定存储空间的容量。
		容易造成存储空间的“碎片”。
16.链表的核心思想是工作指针后移
17.链表插入的时候(这两句顺序不能反)
    s->next = p->next;
	p->next = s;
18.快慢指针原理
   查询不知道长度为多少的链表的中间节点。
   定义两个指针，一个为慢指针（一次移动一个位置），一个为快指针（一次移动两个位置），当快指针移动到最后时，慢指针就移动到了中间
19.魔术师发牌，数第一张为A,第二张为2，第三张为3 ...
20.拉丁方阵n*n,每行每列元素只出现一次  {{1,2,3},{2,3,1},{3,1,2}}
21.不需要括号的后缀表达式，称为逆波兰表达式(RPN)
22.遇到运算符就出栈(两个元素)，运算完成后再入栈(一个元素)。
23.中缀表达式转换为后缀表达式
	从左到右遍历中缀表达式的每个数字和符号，若是数字则直接输出，若是符号，
	则判断其与栈顶符号的优先级，是右括号或者优先级低于栈顶符号，则栈顶元素依次出栈并输出，
	直到遇到左括号或栈空才将吃屎的那个符号入栈。
24.队列在实现上更愿意用链式存储结构，而不愿意用顺序存储结构
25.斐波那契(黄金分割数列)数列【兔子繁殖】f(n+1) = f(n)+f(n-1) f(1) = 1,f(0) = 0
26.分治思想
	分而治之的思想古已有之，秦灭六国，统一天下正是采取各个击破、分而治之的原则。
	分治思想和递归算是有亲兄弟的关系了，因为采用分治思想处理问题，其各个小模块通常具有与大问题相同的结构，这种特性也使递归技术有了用武之地。
27.汉诺塔递归算法
	// 将 n 个盘子从 x 借助 y 移动到 z
	void move(int n, char x, char y, char z)
	{
		if( 1 == n )
		{
			printf("%c-->%c\n", x, z);
		}
		else
		{
			move(n-1, x, z, y);				// 将 n-1 个盘子从 x 借助 z 移到 y 上
			printf("%c-->%c\n", x, z);		// 将 第 n 个盘子从 x 移到 z 上
			move(n-1, y, x, z);				// 将 n-1 个盘子从 y 借助 x 移到 z 上
		}
	}

	int main()
	{
		int n;

		printf("请输入汉诺塔的层数: ");
		scanf("%d", &n);
		printf("移动的步骤如下: \n");
		move(n, 'X', 'Y', 'Z');

		return 0;
	}
28.BF(brute force暴风)算法
	有两个字符串S和T，长度为N和M。首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等，则T向右移动一个字符的位置，再依次进行比较。
	该算法最坏情况下要进行M*(N-M+1)次比较，时间复杂度为O(M*N)。
29.kmp算法
	1.KMP算法求解什么类型问题
	字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。 
	2.KMP算法的核心就是避免不必要的回溯,问题由模式串决定，不是由目标决定！
	3.NEXT数组：当模式匹配串T失配的时候，NEXT数组对应的元素指导应该用T串的哪个元素进行下一轮的匹配。
30.树
	1.树(Tree)是n(n>=0)个结点的有限集。当n=0时成为空树
	2.树有且仅有一个特定的称为根(Root)的结点
	3.当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1、T2、...、Tm，其中每一个集合本身又是一棵树，并且称为根的子树
	4.n>0时，根结点是唯一的，坚决不可能存在多个根结点。
	5.m>0时，子树的个数是没有限制的，但它们互相是一定不会相交的。
	6.结点拥有的子树数称为结点的度(Degree)
	7.度为0的结点称为叶结点(Leaf)或终端结点
	8.度不为0的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点。
	9.结点的子树的根称为结点的孩子(Child)，相应的，该结点称为孩子的双亲(Parent)，同一双亲的孩子之间互称为兄弟(Sibling)
	10.结点的层次(Level)从根开始定一起，根为第一层，根的孩子为第二层。
	11.其双亲在同一层的结点互为堂兄弟
	12.树中结点的最大层次称为树的深度(Depth)或高度
31.二叉树
	1.二叉树的五种基本结构
		a)空二叉树
		b)只有一个根结点
		c)根结点只有左子树
		d)根结点只有右子树
		e)根结点既有左子树又有右子树
	2.特殊的二叉树
		a)斜树，只有左子树或只有右子树
		b)满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。
		c)完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点位置完全相同，则这棵二叉树称为完全二叉树。
	3.满二叉树的特点
		a)叶子只能出现在最下一层。
		b)非叶子结点的度一定是2。
		c)在同样深度的二叉树中，满二叉树的结点个数一定最多，同时叶子也是最多
	4.完全二叉树的特点
		a)叶子结点只能出现在最下两层。
		b)最下层的叶子一定集中在左部连续位置。
		c)倒数第二层，若有叶子结点，一定都在右部连续位置。
		d)如果结点度为1，则该结点只有左孩子。
		e)同样结点树的二叉树，完全二叉树的深度最小。
	5.满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。
	6.二叉树的性质
		a)在二叉树的第i层上至多有2^(i-1)个结点(i>=1)
		b)深度为k的二叉树至多有(2^k)-1个结点(k>=1)
		c)对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1
		d)具有n个结点的完全二叉树的深度为logn+1[logn向下取整]
		e)如果对一棵有n个结点的完全二叉树(其深度为logn+1)[logn向下取整]的结点按层序编号，对任一结点i(1<=i<=n)有以下性质：
			如果i = 1，则结点 i 是二叉树的根，无双亲；如果i > 1，则其双亲是结点?i/2?	
			如果2i > n，则结点 i 无做左孩子(结点 i 为叶子结点)；否则其左孩子是结点2i
			如果2i+1 > n，则结点 i 无右孩子；否则其右孩子是结点2i+1
	7.二叉树的遍历
		a)前序遍历：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。（根左右）
		b)中序遍历：左根右
		c)后序遍历：左右根
		d)层序遍历：按层从左到右
32.树、二叉树、森林之间的转换
	1.树->二叉树：
		加线，在所有兄弟结点之间加一条连线。
		去线，对树中每个结点，只保留它与第一孩子结点的连线，删除它与其他孩子结点之间的连线。
		层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。		
	2.森林->二叉树：
		把每棵树转换为二叉树。
		第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来
	3.二叉树->树：
		
	4.二叉树->森林：
33.判断一棵二叉树能够转换成一棵树还是森林
	只要看这棵二叉树的根结点有没有右孩子，有的话就是森林，没有的话就是一棵树。
34.树的遍历分为两种方式
	先根遍历：先访问树的根结点，然后再依次先根遍历根的每棵子树。
	后根遍历：先依次遍历每棵子树，然后再访问根结点。
35.树、森林的前根（序）遍历和二叉树的前序遍历结果相同，树、森林的后根（序）遍历和二叉树的中序遍历结果相同！
36.名词解释
	定长编码：像ASCII编码
	变长编码：单个编码的长度不一致，可以根据整体出现频率来调节
	前缀码：所谓的前缀码，就是没有任何码字是其他码字的前缀
37.赫夫曼树
a)
b)
c)
d)