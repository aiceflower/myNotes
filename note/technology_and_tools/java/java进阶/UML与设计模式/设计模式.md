[toc]
助记：

- 单依接开特(迪)合里
- 原建抽工单
- 装适组桥享外代
- 中访策备迭，观模命状解职

### 设计模式概述

#### 设计模式基本原则

1. 单一职责原则：一个类只负责一项职责。
2. <span style="color:red">依赖倒置原则</span>(重要)：高层不应该依赖底层模块。<span style="color:red">依赖于接口，而不要依赖于具体的实现</span>。(理念：相对于细节的多变性、抽象的东西要稳定的多)
3. 接口隔离原则：不要强迫客户端依赖他们不需要的接口，一个接口应该只提供一种对外的功能，不要把多操作封装到一个接口中。一个类对另一个类的依赖应该建立在最小的接口上。
4. <span style="color:red">迪米特法则</span>(重要)最少知道原则：一个对象应当对其它对象尽可能少的了解，从而<span style="color:red">降低</span>各个对象之间的<span style="color:red">耦合</span>。只提供一个公共方法，其它无关的全封装在内部，我不需要知道。
5. <span style="color:red">开闭原则</span>(重要,**总纲**)ocp：对修改关闭(对使用方)，对扩展开放(对提供方)。类的改动是通过增加代码进行的，而不是修改原代码。(<span style="color:red">多态是关键</span>)
6. 里氏替换原则：任何抽象类(基类)出现的地方，都可以用它的实现类(子类)进行替换。意思是尽量不要重写父类的方法。父类改变要考虑所有子类。
7. 合成复用原则：尽量使用组合/聚合(has a)而不是继承(is a)

#### **设计模式助解**

- 七个原则的核心思想：找出程序中可能变化的地方把它们独立出来；面向接口编程而不是面向实现；为个各对象间的<span style="color:red">高内聚、松耦合</span>而努力。即以下几个原则：
  - <span style="color:red">可维护性</span>:修改时，改的地方越少，可维护性越好。
  - <span style="color:red">可复用性</span>:可重复使用。
  - <span style="color:red">可扩展性</span>:添加功能不修改原有代码。
  - <span style="color:red">灵活性</span>:接口可灵活调用。
- 用抽象构建框架，用实现扩展细节。
- 设计模式原则就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础。
- 通常我们应该遵守单一职责，只有当逻辑足够简单，才可以在代码级别违反单一职责，可以在方法级别上保持单一职责。
- 大多数设计模式，就是多态。**多态是面向对象的核心**，理解多态才能进一步理解设计模式，才能进一步了解面向对象这种思想的优势之所在。
- 为什么需要设计？针对软件将来具有更好的复用性、扩展性、稳定性、可维护性(可读性、规范性)、灵活性、高内聚低耦合等等。
- 接口和抽象类的的目的是定制好规范，细节交给实现类。其价值在于设计。 

#### 类之间的关系

- 依赖：只要在类中用到了对方，那么他们之间就存在依赖关系。无论是属性、形参、局部变量、还是返回值等，没有对方编译都通过不了。
- 泛化(继承)：A继承了B，则A和B存在泛化关系。
- 实现：接口B被类A实现了，A和B存在实现关系。
- 关联：类与类之间的联系，表现为成员变量。有导航性，单向或双向；多重性，可以有多个。
- 聚合：表示整体和部分的关系，并且可以分开。
- 组合 ：表示整体和部分的关系，并且不可分开。

#### 设计模式分类

##### <span id = "1">创建型模式</span>

- 单例模式
- 抽象工厂模式
- 工厂模式
- 原型模式
- 建造者模式

##### 结构型模式

- 适配器模式
- 桥接模式
- 装饰模式
- 组合模式
- 外观模式
- 享元模式
- 代理模式

##### 行为型模式

- 模板方法模式
- 命令模式
- 访问者模式
- 迭代器模式
- 观察者模式
- 中介者模式
- 备忘录模式
- 解释器模式
- 状态模式
- 策略模式
- 职责链模式

### 具体的设计模式

#### 单例模式(Singleton)

**说明:**

​	保证一个类任何时候只有一个实例，并提供一个访问它的全局访问点。

**实现：**

**<span style="color:red">饿汉式</span>**(推存使用)

类加载到内存后，就实例化一个单例。**JVM保证单例与线程安全**(一个类只加载一次)。

```java
//私有构造方法
private Object(){}
//创建一个对象
private final static Object INSTANCE = new Object();
//对外提供访问方式
public static Object getInstance(){
  return INSTANCE;
}
```

**懒汉式**

​	使用的时候才对其初始化。**线程不安全**。

**DCL**

​	双重检测匹配Volatile。

**<span style="color:red">静态内部类</span>** **(推荐使用)**

加载外部类时不会加载内部类，可以实现懒加载。**JVM保证单例与线程安全**。

```java
public class Singleton{
	private Singleton();
  private static class SingletonHolder{
    private final static Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance(){
    //在使用的时候才会加载SingletonHolder，此时才创建对象
    return SingletonHolder.INSTANCE;
  }
}
```

**枚举实现**

不仅可以解决线程同步，而且可以防止反序列化。

前面的实现方式，无法反射的方式(反序列化)创建实例。枚举不会被反序列化的原因是：**枚举类无构造**方法。

```java
public enum	Singleton{
  INSTANCE;
  public void m(){};//其它方法
}
```

**应用**

​	场景：需要频繁创建和销毁的对象，创建对象时耗时过多或资源消耗过大，经常使用的对象工具类、数据源、session工厂等。

​	Spring Bean实例化多数使用单例。

​	JDK中的Runtime类使用了单例(饿汉式)。

思考：

​	枚举只给静态方法，是否单例。抽象类是否单例。接口默认方法是否单例。

#### 工厂模式(Factory)

**定义：**任何可以产生对象的方法或类，都可以称为工厂。最开始工厂分为抽象工厂和工厂方法，后面又简单工厂、静态工厂。有人说单例也是一种工厂。

为什么有了new后还需要工厂？工厂可以灵活控制生产过程，加权限、修饰、日志等。

- 简单工厂：定义一个工厂类，可以根据输入的不同返回不同类的实例。核心工厂完成所有对象的创建，扩展性不好。
- 工厂方法：对每一种对象都有一个工厂类，工厂类实现统一创建对象的接口。使用继承，通常提供一种产品。
- 抽象工厂模式：将工厂抽象成两层，抽象工厂和具体实现的工厂子类。工厂可以生产一类产品。使用接口实现，通常提供一类产品。

**应用：**

- JDK中的Calendar类(简单工厂)
- 1、日志记录器；2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。(工厂方法)
- 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。(抽象工厂)

#### 原型模式(Prototype)

**说明：**用原型实例指定创建对象的种类，并且通过拷贝原型，创建新的对象。即: 对象.clone(); 要实现Cloneable接口.默认是浅拷贝(Object的克隆是拷贝一份内存)。如果要深拷贝可以自己处理引用类型，或使用对象<span style="color:red">序列与反序列化</span>实现深拷贝。

**应用：**

- 创建新的对象比较复杂时，可以使用原型模式简化对象创建过程。

- Spring Bean创建时使用了原型模式。 指定prototype的bean创建的时候。

**特点：** 

- 不用重新初始化对象，而是动态的获取对象运行时状态。
- 要为每个类配备一个克隆方法。对新类来说不难，但对已有类进行改造时需要修改源码。<span style="color:red">违背了ocp原则</span>。

String虽然是引用类型，但不需要深拷贝，都是指向的常量池，修改的时候不会动原本的，会创建新的。

#### 建造者模式(Builder)

**说明：** 可以将复杂对象的创建过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。一步一步创建一个复杂的对象。

**四个角色：**

- Product产品角色：一个具体的产品对象
- Builder抽象建造者：创建一个Product对象的各个部件，指定的接口/抽象类
- ConcreteBuilder具体建造者：实现接口，构建和装配各个部件。
- Director指挥者：构建一个使用Builder接口的对象。隔离了客户与对象的生产过程。负责控制产品对象的生产过程。

**应用：**

- JDK中的StringBuilder类，使用了建造者模式。
- 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"

#### 适配器模式(Adapter)

**说明：**将某个类的接口，转换成客户端期望的另一个接口，主要目的是兼容性，将原本不兼容的接口融合在一起工作。别名**Wrapper**。A想调用B不能直接用，中间做了个缓冲层Adapter，A-->Adapter-->B。

**适配器模式分类：**

- 类适配器模式(通过继承)
- 对象适配器模式：用关联代替继承，合成利用原则。
- 接口适配器模式(实现)。对于不想使用其它全部方法的情况，可以先创建一个抽象类，以空方法的形式实现全部接口，然后子类按需实现。

**应用：**

- Spring MVC中的HandlerAdapter，使用了适配器模式
- IO流中的连接字符与字节流的桥梁(InputStreamReader和OutputStreamWriter)就是适配器模式
- 转接头

#### 桥接模式(Bridge)

**说明：**将实现与抽象放在两不同的类层次中，即<span style="color:red">分层</span>，使两个层次可以独立改变，用聚合的方式(桥)连接抽象与实现。基于类的最小设计原则。难点在于怎么把桥抽象出来。

**角色：**

- 调用类
- 桥接类
- 实现类

**应用：**

- java中Jdbc的Driver接口使用了桥接模式，下面有Mysql的Driver实现和Oracle的Driver实现。

#### 装饰者模式(Decorator)

**说明：**动态的将新功能附加到对象上。在对象功能扩展方面比继承更有弹性，体现了开闭原则。装饰者关联被装饰者。无限套娃。

**角色：**

- 被装饰者
- 装饰者

**应用：**

- JDK中的IO流，使用装饰者模式。

#### 组合模式(Composite)

**说明：**树状结构专用模式。又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示整体部分的层次关系。

**应用：**

- 学校->学院->系 等组织构架，使用到树结构时想到组合模式就行。
-  JDK中AWT包和Swing包的设计是基于组合模式 ，在这些界面包中为用户提供了大量的**容器构件**（如 Container ）和**成员构件**（如 Checkbox 、 Button 和 TextComponent 等），他们都是继承、关联自抽象组件类Component。

#### 外观模式(Facade)

**说明：**也叫过程模式，门面模式，外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口(封装各子秕一系列复杂的操作)使得这一子系统更加易用。对外屏蔽了子系统的细节。

**角色：**

- 外观类：为调用者提供统一的调用接口
- 调用者：外观接口调用者
- 子系统集合：功能的实际提供者

**应用：**

- Mybatis 中的Configuration创建MetaObject对象使用到了外观模式。
- 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。

#### 享元模式(Flyweight)

**说明：**运用共享技术有效地支持大量细粒度的对象。

**应用：**

- 最经典的应用是池化技术：String常量池、数据库连接池、缓冲池，线程池
- JDK中Integer等类，使用到了享元模式

#### 代理模式(Proxy)

**说明：**重复利用对象。为一个对象提供一个替身，以控制这个对象的访问，即通过代理对象访问目标对象。被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象。

**分类：**

- 静态代理：使用时需要定义接口或父类，代理对象与目标对象一起实现相同接口或继承相同父类。
  - 优：在不修改目标对象的基础上，对过代理对象对目标对象功能扩展。
  - 缺：代理对象需要与目标对象实现同样的接口，会出现很多代理类。一旦接口增加方法，目标对象与代理对象都要维护。

```java
//接口
public interface Teacher{
  void teach();
}
//目标对象
public class TeacherDao implements Teacher{
	public void teach(){
    System.out.println("上课");
  }
}
//代理对象
public class TeacherDaoProxy implements Teacher{//与目标对象实现相同的接口
  TeacherDao dao;//依赖目标对象
  public TeacherDaoProxy(TeacherDao dao){
    this.dao = dao;
  }
  public void teach(){//增强并调用目标对象的方法
    System.out.println("增强开始");
    dao.teach();
    System.out.println("增强结束");
  }
}
```

- 动态代理：代理对象不需要实现接口，只有目标对象需要实现，代理对象的生成利用JDK的API，动态在内存中构建代理对象，动态代理也叫JDK代理，接口代理。JDK 动态代理采用字节重组，重新生成对象来替代原始对象，以达到动态代理的目的。JDK 动态代理生成对象的步骤大致如下。
  1. 获取被代理对象的引用，并且获取它的所有接口。
  2. JDK 动态代理类重新生成一个新的类，同时新的类要实现被代理类实现的所有接口。
  3. 动态生成 Java 代码，新加的业务逻辑方法由一定的逻辑代码调用（在代码中体现），拿到被代理对象的引用。
  4. 编译新生成的 Java 代码 .class 字节码文件。
  5. 重新加载到 JVM 中运行。

```java
//动态代理类
public class TeacherDaoProxy{
	public Object target;
	public TeacherDaoProxy1(Object target){
		this.target = target;
	}
  /**
  * Proxy.newProxyInstance(loader, interfaces, handler); 
  *	loader:目标对象使用的类加载器
  * interfaces:目标对象实现的接口
  * handler: 事件处理，执行目标方法时会触发事件处理
  */
	public Object getInstance(){
		return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
			@Override
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
				System.out.println("动态代理开始");
				Object invoke = method.invoke(target, args);
				System.out.println("动态代理结束");
				return invoke;
			}
		});
	}
}

//调用者
public static void main(String[] args) {
		TeacherDao dao = new TeacherDao();
		Teacher proxy1 = (Teacher) new TeacherDaoProxy1(dao).getInstance();
		proxy1.teach();
}
```

- Cglib代理: 在内存中构建一个子类对象，实现对目标对象功能扩展。底层使用字节码处理框架ASM来转换字节并生成新的类，代理类不能是final的。

```java

public class ProxyFactory<T> implements MethodInterceptor {
	T target;//目标代理对象

	public ProxyFactory(T target){
		this.target = target;
	}

	public T getInstance(){
		//创建一个工具类
		Enhancer enhancer = new Enhancer();
		//设置父类
		enhancer.setSuperclass(target.getClass());
		//设置回调方法
		enhancer.setCallback(this);
		//创建代理对象
		return (T) enhancer.create();
	}

	//回调方法，会调用目标对象方法
	@Override
	public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
		System.out.println("cglib 代理开始");
		Object invoke = method.invoke(target, objects);
		System.out.println("cglib 代理结束");
		return invoke;
	}
}

//调用者
public static void main(String[] args) {
		TeacherDao dao = new TeacherDao();
		Teacher proxy = new ProxyFactory<Teacher>(dao).getInstance();
		proxy.teach();
}
```



**对比：**

​	静态代理和JDK代理需要目标对象实现接口。Cglib可代理单独的对象，并不需要实现接口。当目标对象需要实现接口时使用JDK代理，目标对象不需要实现接口时使用Cglib代理。

**代理模式的几种变体：**

- 防火墙代理：内网通过代理穿透防火墙，实现对公网的访问。
- 缓存代理：请求资源时，先到缓存代理获取，取到返回，取不到去公网或数据库取，再缓存。
- 远程代理：远程对象的本地代理，把远程对象当本地对象来调用。
- 同步代理：主要使用在多线程编程中，完成多线程间同步工作。

**应用：**

- **Spring AOP就是基于动态代理的**，如果要代理的对象，实现了某个接口，那么Spring AOP会使用**JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，这时候Spring AOP会使用**Cglib**，生成一个被代理对象的子类，来作为代理

- Mybatis中的Mapper使用JDK动态代理
- 记录日志、时间、权限、事务、benchmark测试等

#### 模板方法模式(Template Method)

**说明：**在一个抽象类中公开定义了方法的模板，子类按需重写方法。调用按抽象类中的模板(定义成final不让子类覆盖)进行。也可在抽象类中添加钩子方法(空方法)，子类按需实现。

**应用：**

- Spring中Bean的创建与初始化使用了模板方法模式。refresh();模板方法。
- 钩子函数，回调函数都用模板方法。

#### 命令模式(Command)

**说明：**需要向某些对象发送请求，但不知道请求的接收者是谁，也不知道被请求的操作是哪个。命令的发送者，不知道命令的执行者是谁。可以实现undo的功能。如果是一系列undo可以用责任链模式，将一连串命令放入集合中。命令模式与记忆模式结合可实现Transaction，命令与责任链结合可实现undo与多次undo，命令与组合命令结合可实现宏命令，树状结构。

**角色：**

- 命令发布者(调用者)Invoker
- 命令连接者(命令)Command
- 命令执行者(被调用者)Receiver

**应用：**

- Spring中的JdbcTemplate使用到了命令模式。

#### 访问者模式(Visitor)

**说明：**将数据结构和操作分离，在被访问对象里，增加一个访问者的接口。应用于结构相对固定的场景。

**应用：**

- ASM操作java字节码，使用的是访问者模式。ClassWriter、ClassReader

#### 迭代器模式(Iterator)

**说明：**用于容器和容器遍历。提供一种遍历集合元素的统一接口，不暴露其内部的结构。但是每个聚合对象都需要一个迭代器，会生成很多迭代器，不好管理。

**应用：**

- JDK ArrayList、HashSet、HashMap都使用了迭代器。Iterator接口。

#### 观察者模式(Observer)

**说明：**向订阅者广播发送消息，通知。事件处理模型。钩子函数、hook、callback、observr、listener都是一回事，本质上都是观察者模式。

观察者模式主要用于1对N的通知。当一个对象的状态变化时，他需要及时告知一系列对象，令他们做出相应。

角色：

- 主题Subject add、remove、notifyAll (相当于事件源和事件)
- 具体主题
- 观察者Observer update(相当于事件监听器)
- 具体观察者

应用：

- JDK中的Observable(相当于Subject)使用观察者模式(使用聚合而不是实现)
- 观察者配合责任链，可以做到根据不同事件，做不同处理。根据不同消息通知不同的人。

#### 中介者模式(Mediator)

**说明：**使用中介对象来封装一系列对象的交互，中介让各个对象不需要显示的交互从而使其解耦。

**门面模式与中介模式的区别：**

- 门面模式(Facade):外部想使用，但内部很复杂，提供一个统一的对外访问的接口，复杂结构内部处理。
- 中介模式(调停者)：内部打交道很乱，抽出一个调停者，所有的部分都与调停者打交道。

**应用：**

- 机场调度系统
- MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。
- 消息中间件

#### 备忘录模式(Memento)

**说明：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样就可以将该对象恢复到原先保存的状态。(记录快照，存盘，可用于恢复)

**角色：**

- Originator:需要保存状态的对象
- Memento:备忘录对象，负责保存好记录，Originator的内部状态
- Caretater:守护者对象，负责保存多个备忘录对象

**应用：**

- 后悔药、游戏存档、Ctrl+Z、undo

#### 解释器模式(Interpreter)

**说明：**给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。

**应用：**

- Spring中SpelExpressionParser、解析Xml使用的dom4j的解析器
- 编译器、运算表达式计算

#### 状态模式(State)

**说明：**主要用到解决对象在多种状态转换时，老百姓对外输出不同行为的问题。状态和行为是一一对应的，不同状态间可以相互转换。

**角色：**

- Context：环境，用于维护状态实例，表示当前状态。
- State：抽象状态角色
- ConcreateState：具体状态角色，每个子类实现一个与状态相关的行为，并实现状态切换。

**应用：**

- TCPConnection根据不同的状态进行不同的处理，应用于操作不怎么进行扩展的时候。
- 有限状态机(FSM)：状态是有限的，状态与状态间的迁移和变化是通过不同的动作来变的。

#### 策略模式(Strategy)

**说明：**一个类的行为或其算法可以在运行时更改。解决在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

**实现：**

```java
//某一例 
public interface Comparator<T>{
  int compare(T t1, T t2);//前大于后返回1
}
```

**应用**：

- JDK的Comparator接口使用了策略模式，根据不同的策略进行比较，排序。

- 诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 
- 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。

#### 责任链模式(Chain of Responsibility)

**说明：**为请求创建一个接收者对象的链，对请求的发送者和接收者进行解耦，每个接收者都有下一个接收者的引用。

**应用：**

- Spring MVC中的HandlerExecutionChain使用了责任链模式。 
- Servlet中的Filter
- java中方法的调用
- 多级请求、请假、审批等流程

### 设计模式应用

#### Spring中的设计模式

1. 简单工厂

   BeanFactory根据一个唯一的标识来获得Bean对象。

2. 工厂方法

   FactoryBean实现了该接口的bean是一类叫作factory的bean。Spring在使用getBean()调用获得该bean时自动调用该bean的getObject()方法,所以返回的不是factory这个bean而是bean.getObject()方法的返回值。

3. 单例代工

   Spring依赖注入Bean默认是单例的。依赖注入都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。使用了双重判断加锁的单例模式。

4. 适配器模式

   原理：SpringMVC中的适配器HandlerAdapter,根据Handler规则执行不同的Handler。

   实现过程：DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdapter发起请求，处理Handler。HandlerAdapter根据规则找到对应的Hanlder并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServlet返回一个ModelAndView。

   意义：HandlerAdapter使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter。SpringMVC的每一种Controller有一种对应的适配器实现类，让适配器代替Controller执行相应的方法。在扩展Controller时只需要增加一个适配器类就完成了SpringMVC的扩展。

5. 装饰器模式

   Spring中用到的装饰器模式在类名上有两种表现：一种类名中含有Wrapper、一种类名中含有Decorator。动态的给对象添加额外的功能。

6. 代理模式

   AOP底层使用的是动态代理。对于实现了某接口的对象使用JDK自带的动态代理，对于未实现接口的对象使用Cglib动态代理。

7. 观察者模式

   Spring的事件驱动模型使用观察者模式，即各种listener。事件机制需要三个部分：事件源、事件和事件监听器。ApplicationEvent事件通过构造器参数得到事件源，ApplicationListener事件监听器。

8. 策略模式

   Spring的资源访问Resource接口是具体资源访问策略的抽象。Spring给了很多默认的策略：UrlResource、ClassPathResource、FileSystemResource、ServletContextResource...

9. 模板方法模式

   父类定义了骨架方法，并规定了方法的执行顺序，某些特定的方法由子类去实现。

#### Mybatis中的设计模式

1. Builder模式

   SqlSessionFactoryBuilder、XMLMapperBuilder

2. 工厂模式

   SqlSessionFactory、MapperProxyFactory

3. 单例模式

   ErrorContext、LogFactory

4. 代理模式

   MapperProxy、ConnectionLogger

5. 组合模式

   SqlNode、ChooseSqlNode

6. 模板方法模式

   BaseExecutor、BaseTypeHandler

7. 适配器模式

   Log接口对jdbc、log4j等各日志框架的适配。

8. 装饰者模式

   cache.decorators包中各个装饰者的实现

9. 迭代器模式

   PropertyTokenizer
