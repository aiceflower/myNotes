算法和数据结构的意义？
我们学习数据结构和算法的意义，通过使用恰当的符合问题场景的数据结构和算法，加快了我们的计算效率。


操作系统
内存中的第一个程序：内核(os),GDT划分空间(用户空间、内核空间)
程序不能直接访问硬件(磁盘、网卡等)、内核可以调用
程序通过系统调用(软中断)访问硬件；硬中断(鼠标、键盘、时钟中断)

IO
epoll
C10K，一万个客户端
阻塞IO：accept后会在receive等待，其它线程无法接入.(开10K线程，线程频繁切换，内存消耗过大)
非阻塞IO：receive不阻塞，或以继续accept（一个线程，每次循环10K调用receive，O(N),可能只有一个用户发数据，浪费）
多路复用(内核发生变化)：select(fds);所有文件描述符传给内核，内核返回可读可写的文件描述符，具体可用的。(10K,O(1)的select，O(m)的receive)
pool主动轮询的多路复用：每次select会传递fds，kernel遍历所有fds
epoll事件驱动的多路复用：epoll_create创建存放文件描述符的空间(监听的fd、可读写的fd)，epoll_ctl(往内核空间add或del文件描述符)，epoll_wait等待内核告诉我哪些fd可读可写(内存会开辟两块空间，一块存放开启的文件描述符，一块存放哪些文件描述符是可用的)[用什么机制把第一块的文件描述符放到第二块？因为是事件驱动，个人感觉是客户端连接和发送数据的时候移动(存疑),实际也是这样，网卡会产生中断，中断的时候处理，会把数据移动过去。]
程序通过多路复用器，知道哪些文件描述符可以操作(accept,receive),然后程序自己去accept和receive，所有的事都是程序自己去干，所以是同步IO，非阻塞。注意状态和读写是两个事，状态使用多路复用，读写还需要程序自己去做。
IO的系统调用：
socket = fd5
bind 8080
listen fd5
epoll_create fd8
epoll_ctl(fd8,add,fd5,accept)
epoll_wait(fd8)
accept fd5 -> fd6
epoll_ctl(fd8,fd6)

同样是epoll为什么redis是轮询，nginx是阻塞？
	redis的一个线程除了接收客户端，还会干很多事情，比如LRU、LFU、RDB、AOF等所以需要轮询。
	nginx一个线程就干一个事，等客户端来，来了之后才干活。

linu

linux网络模型：阻塞 IO 、非阻塞 IO 、多路复用IO、信号驱动式 IO 、异步 IO

/proc/pid(某个进程号)/fd 存放io数(file、socket、pipeline)
/proc/pid(某个进程号)/task 线程数
默认安装man，需要安装 man-pages
mmap，让用户程序和内核程序有一部分空间是打通的，而且打通的级别是可以直接映射到磁盘的文件上。程序将数据写到缓冲页，内核直接将数据刷到内存。程序往硬盘写数据，不进行频繁的系统调用，使用mmap可将数据直接写到硬盘（内存映射）
strace -ff -o /home/log/strace-nginx/nginx ../sbin/nginx  监听某个程序并记录日志
netstat -natp 查看tcp进程
tcpdump -nn  -i eth0 port 80  监听eth0网卡，80端口
route -n 查看路由表
arp -n 
strace -ff -o ab.txt java TestSocket 抓取程序对内核的系统调用

kafka
接收客户端使用epoll，客户端发送数据，kafka通过系统调用读，kafka加头信息，放入缓存，数据到达一定级别后，使用mmap技术，刷到磁盘。通过mmap减少写的系统调用。
0拷贝的数据是不需要程序加工，直接发送


网络 IO kernel 计组 算法(这里是根本)
框架 中间件 分布式 设计模式-CAP-方法论
项目设计 架构(三高)

互联网三高
	高性能、高扩展、高可用
高性能
	响应(低延时)
	吞吐(高吞吐量，高并发)
如何提高系统的性能？
	从以下两个方面入手：1.降低延时 2.提高吞吐量
amdahl(阿姆达尔定律):
	想要显著加速整个系统，必须提升系统中相当大的部分的速度(a-b-c-d-e...)
	这个定律告诉我们，提高系统的响应比较困难，所以现在很多系统的性能提升体现在吞吐量上。
例子：
	集群-吞吐
	负载均衡-吞吐
	缓存-响应
	JVM-响应
	分库分表-吞吐，响应
	Tomcat非阻塞-响应
	MQ异步-响应

多线程与锁：
是不是线程越多越好？
	不是，切换线程需要消耗系统资源。线程过多会把大量的资源浪费在线程切换上。如何找到线程的平衡点--压力测试。
多线程三大特性：
	可见性、有序性、原子性
synchronized
	如何把对象当成锁？就是修改对象头，记录锁信息。
	加锁后从并发变成序列化执行。互斥锁。
	有没有锁让多个线程同时执行？信号量。

synchronized实际上是一把悲观锁(不一定有人跟我抢，但是我也要上锁)
乐观锁：自旋锁、无锁、CAS(compare and swap)，都是一个概念。写之前先比较。
	写之前有人已经改了，读->计算->修改(重复这一过程，自旋)
乐观锁的问题：
	1.ABA问题，比较时相同，但这可能是被别人改过，又改回来了。(加版本号，或加boolean解决)
	2.原子性问题，CAS操作必须保证原子性。JDK->unsafe.java.compareAndSwapint->unsafe.cpp->Atomic::compxhg->asm:cmpxchg(汇编指令,多核cpu不保证原子性)，最后如何保证(lock_if_mp compxhg，如果是多处理器则上把锁,相当于锁总线)，即CAS在底层实际是上锁
是否是CAS一定比悲观锁效率高？什么时候用CAS，什么时候用悲观锁？
	不一定，使用悲观锁其它人会排队，可使用时，由线程调度算法通知使用。乐观锁其它人会循环，耗cpu。即，如果锁中的内容执行很快，则使用CAS，如果执行时间长则使用悲观锁(关键看写操作是否耗时)。
	能用synchronized优先使用它，现在它内部有锁升级过程，无锁-->偏向锁-->自旋锁-->悲观锁
偏向锁：
	应用于第一个线程，第一个人来的时候，打上标签，jdk15后弃用。为什么会有偏向锁，工业统计，大多数情况只有一个线程使用锁。



TCP/IP协议
nc www.baidu.com 80   建立连接 -s指定源ip -p 指定端口
TCP是什么？
	面向连接的，可靠的传输控制协议，数据不重复，不丢失，不失序。
	3次握手建立连接->发送，接收数据->4次挥手断开连接
连接是什么？
	三次握手后，两端开辟的为对方提供服务的资源(具体为socket、队列等)。连接是虚无的。
为什么是三次握手？SYN -> SYN/ACK -> ACK
	TCP是面向连接的，可靠的传输控制协议，只有三次才能保证两端都知道双方可以正常收发数据。
如果第三次的ACK没收到，客户端发送的数据会收吗？
	不收，如果没收到ACK，在超时时间内没等到ACK,服务端会继续发送SYN/ACK(重试下),等客户端回复，如果一直没收到客户端的ACK则断开连接，如果收到了则建立连接成功，可继续通信。
什么是socket？
	1.无论是套接字还是插座必须是配套的，两对ip:port,这四个组合在一起在任何两端具备唯一性。
	2.具有自己的队列
端口号是什么？
	用端口号代表一个服务。范围是0-65535。
服务端开辟80端口，可以与一个客户端建立多少个连接？如果建立了65535个连接后，还想再建立连接怎么办？
	针对客户端的一个ip可以建立65535个，如果想再建立有两种办法：1）服务端新开辟一个端口，2）客户端再创建一个ip。核心是：ip_src:port_src -- sp_des:port_des唯一就行，例如：客户端使用两个ip(虚拟网卡)同一个端口可与服务器建立两个连接
服务端开启监听后，使用read阻塞，还能与客户端建立连接吗？
	可以，应用程序阻塞与TCP无关，三次握手是由内核处理的，与应用程序无关(TCP/IP协议族除了应用层，其它都由内核提供)，建立连接后socket和客户端发送的数据，都在内核的队列中等待本机应用去获取。(可通过netstat -natp的Recv-Q 和Send-Q去验证)
程序如何处理网络IO？
	建立连接和收发数据都由内核完成，完成后将连接和数据放在内存队列中，应用程序读取数据，相当于读取本地的内存。程序使用网络IO时，面向的是自己的kernel当中的queue。
各种IO？
	程序读取内核中的queue时，如果里面没数据，没读到，程序等待则为阻塞IO、如果程序继续去干其它的事，一会儿再来读则为非阻塞IO。(kernel不会主动通知，都是程序自己去获取)
为什么是四次分手？(FIN->FIN/ACK->FIN->ACK)(没有收到也会有重试机制)
	双方在断开前可能还有数据需要给对方发送？所以需要发送断开请求，及收到确认，才能释放资源(queue)
为什么建立连接是三次，而挥手是四次？
	关闭连接时允许半关闭，半打开状态，这时一方还可以同另一方发送数据，而连接建立时不允许有半连接状态。
数据包如何从一台主机发送到另一台主机？
	1.传输控制层有了第一个握手的包(依赖网络层)
	2.网络层(IP、路由表) /etc/sysconfig/network-scripts/ifcfg-eth0 网络配置(ip、掩码、网关) route -n 查看路由表
	将目标ip地址与上掩码genmask(从上到下)，与destination比较如果相同，则发往对应的geteway(下一跳)，如果gateway是全0(局域网)则直接发送，如果不是则发送给网关。
	3.(数据链路层)发送给下一跳的数据包为目标地址的ip地址和下一跳的mac地址 arp -n
	client -->  route --> ISP --> ... --> baidu
	ip:ip_baidu,mac:mac_route --> ip:ip_baidu,mac:mac_isp --> ip:ip_baidu,mac:mac_baidu --> baidu收到后发现ip是自己，mac是自己,拆包找端口号匹配成功

ACID
AD  通过undo和redo实现
CI 	通过lock实现

文件系统：
1.ext2/ext3/ext4, ntfs, fast32 与内核一起，对磁盘数据进行组织,对磁盘做一个索引的作用
2.gfs, fastdfs, hdfs, tfs 基于操作系统，实现对文件的分布式存储
3.fuse 用户态的fs，在内核中放到用空空间调用的东西，对内核进行文件写入时，会回调用户空间的fuse，可以监控内核每个文件的变化



1.如何解决hash冲突？
	1.探测(线性寻址),插入出现冲突则，线性探测下一个空闲位置插入。查找同理，删除则需要设置标记，否则查找会出问题。(扩容慢)
	2.拉链(链表)，(使用简单,增删快，遍历慢)
2.2-3查找树
	2-3查找树类似BST，需要满足以下条件：
		2-节点：含有一个键-值和两条链，左链接指向2-3树中的键都小于该节点，右链接指向的2-3树的键都大于该节点。
		3-节点：含有两个键-值和三条链，左链...小于该节点，中键...位于该节点的两个键之间，右键...大于该节点。·
	2-3树的性质：
		任意空链到根节点的路径长度都是相等的。
		与普通二叉树的区别在于，普通二叉树是自顶向下生长，2-3树是自底向上生长(同B-Tree和B+Tree)
3.红黑树
	红黑树出现的原因：
		AVL树的条件太苛刻，左右高度差不能超过1
		左右高度差不会超过二者中较低那个的一陪。
	2-3-4树转红黑树：
		2节点(1个节点两个子节点) 	黑
		3节点(2个节点三个子节点)   左倾或右倾，上黑下红
		4节点(3个节点，四个子节点) 中间黑，两边红

	描述：
		红黑树主要对2-3树进行编码，其思想是用标准的二叉查找树(完全由2节点构成)和一些额外的信息(替换3-节点)来表示。树中的链接分为两种，红链接：将两个2-节点连接起来构成一个3-节点，黑节点：2-3树中的普通链接。
	红黑树的性质：
		1.节点是红色或黑色
		2.根是黑色
		3.所有叶子都是黑色(叶子是nil节点)
		4.每个红色节点必须有两个黑色的子节点(不能有两个连续的红色节点)
		5.从任一节点到其每个叶子的所有简单路径都包含相同的黑色节点(黑色平衡) 
	变色：
		节点颜色由红变黑，或由黑变红。 
	左旋：
		以某个节点作为旋转点，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变。
	右旋：	
		以某个节点作为旋转点，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。
	新增：
	分情况讨论，主要是要找到插入位置，然后自平衡（左旋或者右旋）且插入节点是红色（如果是黑色的话，那么当前分支上就会多出一个黑色节点出来，从而破坏了黑色平衡），以下分析全部以左子树为例子，右子树的情况则相反。
		1.(1节点直接为根)如果插入的是第一个节点（根节点），红色变黑色【最终黑色】
		2.(2节点直接合并，上黑下红)如果父节点为黑色，则直接插入，不需要变色【最终上黑下红】
		3.(3节点)如果父节点是红色，没有叔叔节点或者叔叔节点是黑色（此时只能是NIL节点），则以爷爷节点为支点右旋，旋转之后原来的爷爷节点变红色，原来的父节点变黑色。【即，最终结果是中间节点是黑色，两边节点是红色】
		4.(4节点)如果父节点为红色，叔叔节点也是红色（此种情况爷爷节点一定是黑色），则父节点和叔叔节点变黑色，爷爷节点变红色（如果爷爷节点是根节点，则再变成黑色），爷爷节点此时需要递归（把爷爷节点当做新插入的节点再次进行比较）【最终上面一层是红，中间一层两个是黑，下面一层是红】
		总原则就是根据2-3-4树的最终状态，得到红黑树的最终状态，进行调整
		右子树的情况和左子树类似，请自行研究，不再整述。
	删除：
		BST删除：
		1.删除叶子节点，直接删除
		2.删除的节点有一个叶子节点，用叶子节点替代
		3.删除的节点有两个叶子节点，找到前驱节点或后继节点来替代
			前驱：左边最大的，后继：右边最小的
			实际删除是将内容替换为前驱或后继，然后再删除前驱或后继，相当于删除前两种情况
		红黑树删除：
		红黑树的下两层，一定对应2-3-4树的叶子节点
		即删除红黑树的节点，一定对应2-3-4树的叶子节点(有一种情况可以转换为删除叶子)
		1.删除2-3-4树中的3节红色直接删除，黑色删除后用红色代替，红色变黒色
		2.删除2-3-4树中的4节点，直接删除(只可能删除红色节点)
		3.删除2-3-4树中的2节点，此时删除的是黑色节点，会打破平衡。两种情况：1种跟兄弟借，兄弟可以借(有两个节点)，则删除后兄弟变父亲，父亲变兄弟。
	红黒树的表示：
		Node 	left;	//左子节点
		Node 	right;	//右子节点
		T    	k;		//存储键
		V    	v;		//存储值
		boolean color;	//父节点，指向它的链接的颜色。true-红，false-黑
	平衡化：
		红黑树进行增删改操作后，可能会出现红色右链接或两条连续的红连接，不满足红黑树的定义。需要通过旋转进行修复。
		左旋：当某个节点的右节点为红色时，需要左旋
		右旋：左子节点为红色，左子节点的左子节点为红色(即两个连续的红色连接)，需要右旋
		右旋转后左右节点都是红色连接，这时需要进行颜色反转(将当前节点变红，将左右节点变黑)
4.Mysql B+Tree B-Tree
	高度为2可以存放18720数据，高度为3可以存放21902400数据，mysql一页16K=4个内存页
	B-Tree自底向上分裂
	使用B-Tree是为了提高文件系统从磁盘 读取数据的效率 
	B树：
		一个节点可以有多个key，key的最大个数为B树的阶数。每个节点最多有M-1个key，并且按升序排列。每个节点最多有M个子节点，根节点至少有2个子节点。实际使用中B树的阶数大于100
		找到key即可获取value，B+Tree需要找到最大深度才能找到value。
	B+树：
		非叶子节点仅具有索引的作用，即只存key不存value。
		树的所有叶子节点构成一个有序链表，可以按照key排序的次序遍历全部数据。
		与B树相比在内存相同的情况下可以存放更多的key；叶子节点是相连的，因此对整个树的遍历只需要一次线性遍历既可；由于数据顺序排列并相连所以便于区间查找和搜索。

Volatile：
多核cpu并发缓存构架：
	cpu-cpu寄存器 <---> cpu缓存  <--总线
								   	  \
				L1,L2,L3高速缓存		   --> 主内存(RAM)
								   	  /
	cpu-cpu寄存器 <---> cpu缓存  <--总线
Java内存模型(JMM):
	线程1 <---> 工作内存(共享变量副本)  <-- JMM
									   		\
	线程2 <---> 工作内存(共享变量副本)	<-- JMM	 --> 主内存(共享变量)
									   		/
	线程3 <---> 工作内存(共享变量副本)  <-- JMM 
数据原子操作：
	read(读取):从主内存读取数据
	load(载入):将主内存读取到的数据写入工作内存
	use(使用):从工作内存读取数据来计算
	assign(赋值):将计算好的值重新赋值到工作内存中
	store(存储):将工作内存灱写入到主内存
	write(写入):将store到主内存中的数据赋值给主内存中的变量
	lock(锁定):将主内存变量加锁，标识为线程独占状态
	unlock(解锁):将主内存变量解锁，解锁后其它线程可以锁定该变量
原子性操作中的协议(总线)：
	缓存一致性协议(MESI):多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存，其它cpu通过总线嗅探机制，可以感知到数据的变化，从而将自己缓存里的数据失效。
总线嗅探机制结合缓存一致性协议，实现多线程间的可见性。
Volatile缓存可见性实现原理：
	通过汇编lock前缀指令，它会锁定这块内存区域的缓存(缓存行锁定)并回写到主内存。
	lock指令作用:用于在多处理器中执行指令时对共享内存的独占使用
		1.将当前处理器缓存行的数据立即写回到系统内存
		2.这个写回内存的操作会引起在其它cpu里缓存了该内存地址的数据无效(MESI协议)
		3.提供内存屏障功能，使lock前后指令不能重排序
内存屏障：是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。(读内存屏障，写内存屏障,完全内存屏障)
java对象创建的半初始化：
	Student o = new Student("z3");
	1.new 创建内存空间，变量初始值是null(半初始化，零值)
	2.init 给变量赋值
	3.给引用指向
指令重排序:把执行效率高的指令排在前面，不是乱，是为了提高效率。不影响执行结果。

DCL:
	volatile加双重校验实现单例。


synchronized
	如何描述synchronized？
	Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。
	synchronized是可重入锁，锁的是对象。那它修改的是对象的什么东西。
	上锁其实就是改变对象的对象头。

JVM、HotSpot、openJDK?
JVM是标准/规范
openJDK是开源的项目
HotSpot是sun基于JVM规范开发的虚拟机，大部分代码是openJDK源码，部分商用的未开源

java对象由什么组成？java对象在内存中的布局分为三块区域：(64位虚拟机)
	对象头：Mark Word(8Byte) + Class Pointer(开启对象压缩4字节，不开启8字节，默认4)。
	具体包括：对象的布局、类型、GC状态、同步状态和标识hash码的基本信息。
	实例变量：存放类的属性，包括父类的。如果是数组还包括数组的长度。这部分以
	填充数据：用于对齐，64位虚拟机字节数必须是8的倍数。
新生代到老年代年龄最大为什么是15？
	对象头中的同步状态占4位，最大为15.
对象的几种状态：
	无锁--刚new出来
	偏向锁
	自旋锁
	同步锁
	gc标记


G1 region

-XX:PretenureSizeThreshold 大对象设置，默认为0不管多大放到eden 预占用大小阀值

parallel Scavenge 清道夫



hsdis 查看java汇编，查看lock指令
加如下参数：
-XX:+UnlockDiagnosticVMOptions
-XX:+PrintAssembly
-XX:CompileCommand=compileonly,*JMMTest.*
-server
-Xcomp

jclasslib 查看字节码

---------------微服务---------------
什么是微服务？
	微服务的核心就是把传统的业务繁多单机应用，根据业务将单机应用拆分为一个一个小的服务，彻底解耦，每个服务都提供特定的功能。每个服务都能单独部署甚至可以拥有自己的数据库。这样的由一个一个小的服务组成的服务就是微服务。
微服务使用场景？
	适合：大型复杂项目、快速迭代的项目、并发高的项目(弹性扩缩容)
	不适合：业务稳定、迭代周期长
Spring Cloud:微服务
	spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。
Eureka:服务注册与发现
	是一个高可用的服务注册和发现模块,它没有后端缓存，每一个实例创建后都需要向注册中心发送心跳(可以在内存中完成)。
ribbon:负载均衡
	是一个负载均衡客户端，可以很好的控制http和tcp的一些行为。ribbon会根据服务名来选择具体的服务实例。
Feign:rpc通信
	是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign,只需要创建一个接口并注解。它具有可插拔的注解特性。Feign默认集成了ribbon.
Hystrix:断路器
	Netflix开源了Hystrix组件，实现了断路器模式。 在微服务架构中，一个请求需要调用多个服务是很常见的。较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值(Hystric 是5秒20次)断路器将会被打开。断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。
zuul:路由网关
	Zuul的主要功能是路由转发和过滤器，可以做一些安全验证。Zuul默认和Ribbon结合实现了负载均衡的功能。一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服务。
Config:配置中心
	在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。
Bus:消息总线
	将分布式的节点用轻量的消息代理连接起来(需要消息队列中间件)。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。
Sleuth：服务链路追踪
	主要功能就是在分布式系统中提供链路追踪解决方案，并且兼容支持了zipkin。

注册中心：nacos，替代方案eureka、consul、zookeeper
配置中心: nacos ，替代方案sc config、consul config
服务调用:feign，替代方案：resttempate
熔断：sentinel、，替代方案：Resilience4j
熔断监控：sentinel dashboard
负载均衡:sc loadbalancer
网关：spring cloud gateway
链路：spring cloud sleuth+zipkin，替代方案：skywalking等。

代替方案：
Nacos:
	致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。是Spring Cloud A中的服务注册发现组件，类似于Consul、Eureka，同时它又提供了分布式配置中心的功能，这点和Consul的config类似，支持热加载。
Nacos 的关键特性包括:
	服务发现和服务健康监测
	动态配置服务，带管理界面，支持丰富的配置维度。
	动态 DNS 服务
	服务及其元数据管理

Gateway:
	Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。

Sentinel:
	Sentinel，中文翻译为哨兵，是为微服务提供流量控制、熔断降级的功能，它和Hystrix提供的功能一样，可以有效的解决微服务调用产生的“雪崩”效应，为微服务系统提供了稳定性的解决方案。随着Hytrxi进入了维护期，不再提供新功能，Sentinel是一个不错的替代方案。Hystrix采用线程池对服务的调用进行隔离，Sentinel才用了用户线程对接口进行隔离，二者相比，Hystrxi是服务级别的隔离，Sentinel提供了接口级别的隔离，Sentinel隔离级别更加精细，另外Sentinel直接使用用户线程进行限制，相比Hystrix的线程池隔离，减少了线程切换的开销。另外Sentinel的DashBoard提供了在线更改限流规则的配置，也更加的优化。
Sentinel特性:
	丰富的应用场景： Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、实时熔断下游不可用应用等。
	完备的实时监控： Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。
	广泛的开源生态： Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。
	完善的 SPI 扩展点： Sentinel 提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。例如定制规则管理、适配数据源等。

---------------微服务---------------