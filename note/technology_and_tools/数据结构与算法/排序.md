<center>排序算法</center>



### 排序表

| 中文名称 | 英文名称  | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
| :------: | :-------: | :------------: | :------------: | -------------- | :--------: | :----: |
| 选择排序 | selection |     $n^2$      |     $n^2$      | $n^2$          |     1      |  不稳  |
| 冒泡排序 |  bubble   |     $n^2$      |     $n^2$      | n              |     1      |   稳   |
| 插入排序 | insertion |     $n^2$      |     $n^2$      | n              |     1      |   稳   |
| 快速排序 |   quick   |   $nlog_2^n$   |     $n^2$      | $nlog_2^n$     | $log_2^n$  |  不稳  |
| 归并排序 |   merge   |   $nlog_2^n$   |   $nlog_2^n$   | $nlog_2^n$     |     n      |   稳   |
|  堆排序  |   heap    |   $nlog_2^n$   |   $nlog_2^n$   | $nlog_2^n$     |     1      |  不稳  |
| 希尔排序 |   shell   |   $n^{1.3}$    |     $n^2$      | n              |     1      |  不稳  |
|  桶排序  |  bucket   |      n+k       |     $n^2$      | n              |    n+k     |   稳   |
| 计数排序 | counting  |      n+k       |      n+k       | n+k            |    n+k     |   稳   |
| 基数排序 |   radix   |      n*k       |      n*k       | n*k            |    n+k     |   稳   |

### 肋记口决

选泡插，【简单排序】

快归堆希桶计基，

恩方恩老恩一三，(选泡插 $n^2$, 快归堆 $nlog_2^n$, 希 $n^{1.3}$)

对恩加K恩乘K，(统计 n+k, 基 n*k)

不稳稳稳不稳稳，

不稳不稳稳稳稳！

### 衡量算法的优劣

时间复杂度：忽略常数向，忽略低次方项。

空间复杂度：算法需要用到的额外空间。

是否稳定：两个相同的数，排序前在前的数，排序后可能在后则不稳定。

### 写算法思路

- 由简单到复杂
  - 验证一步走一步
  - 多打印中间结果
- 先局部后整体
  - 同思路时先细分
- 先粗糙后精细
  - 变量更名
  - 语句合并
  - 边界处理

### 算法思想

#### 选择排序

思路：	

​	第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。

评价：

​	基本不用， 不稳

#### 冒泡排序

思路：

​		它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换。

评价：

​	基本不用，太慢

#### 插入排序

思路：

​	将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

评价：

​	样本小，且基本有序的时候效率比较高。

#### 快速排序

思路：

​		通过一趟排序将待排记录分隔成独立的两部分,其中一部分记录的关键字均比另一部分的关键字小,则可分别对这两部分记录继续进行排序,以达到整个序列有序。

评价：

​		双轴快排。

#### 归并排序

思路：

​		采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并

评价：

​		java与python对于对象的排序，要求稳定，使用归并

​		java对于基本类型排序使用双轴快排，对于对象使用TimSort(多路归并，改进的归并) 内也包含binarySort (二分插入排序)

#### 堆排序

#### 希尔排序

思路：

​	希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。

评价：

​	插入排序的改进版，间隔大时移动次数少，间隔小时移动距离短。但是不稳定。

#### 桶排序

思路：

​	找出最大最小值，确定桶的个数，将数组分到有限数量的桶子里。每个桶子再使用其它方式排序。

评价：

​	最坏一个桶，最好n个桶且值排列均匀。空间最好则时间做不到最好，时间最好则空间做不到最好。

#### 计数排序

思路：

不稳定：		1.n个数据，每个数据的范围为k内，申请k+1个元素的数组，每个待排序的数与数组下标相同则下标加1 

​		2.申请n个元素的数组，按元素个数进行复制数组 (0岁的有5个，则前5个元素值为0)

稳定：	1.c[a[i]]++

​				2.c[i] += c[i-1]; i 从1 开始，累加数组

​				3. r[--c[a[i]]] = a[i];//原数组倒排

评价：

​		适用于数量n多但范围k小 ，如（给中国所有人按年龄排序，很多人，但年龄限制在0-100内）		

​		桶排序思想的一种，非比较类型排序

#### 小技巧

1.防止越界

```c
int mid = (left + right)/2; //可能越界
int mid = left + (right-left)/2; //解决
```

2.代码简化

```c
if(arr[i] < arr[j]){
		res[k] = arr[i];
    i++;
    k++;
}else{
		res[k] = arr[j];
    j++;
    k++;
}
res[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];//简化
```

